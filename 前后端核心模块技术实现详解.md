# 水泥厂管理系统 - 后端核心模块技术实现详解

## 文档概述

本文档详细分析水泥厂管理系统中核心模块的技术实现，特别深入讲解Redis和RabbitMQ在系统中的应用场景、实现原理和最佳实践。

## 技术架构总览

### 核心技术栈
- **后端框架**: Spring Boot 3.1.3 + Java 21
- **数据访问**: MyBatis 3.0.0 + PageHelper 1.4.6
- **数据库**: PostgreSQL
- **缓存层**: Redis 7.x
- **消息队列**: RabbitMQ 3.12.x
- **认证授权**: JWT 4.4.0 + Spring Security
- **API文档**: SpringDoc OpenAPI 2.5.0

### 架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 Vue 3    │    │   Spring Boot   │    │   PostgreSQL    │
│                 │◄──►│   后端服务      │◄──►│    数据库       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │      Redis      │
                    │   缓存/会话     │
                    └─────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │    RabbitMQ     │
                    │   消息队列      │
                    └─────────────────┘
```

---

## 1. 水泥厂管理模块

### 1.1 业务逻辑设计

#### 核心功能
- **CRUD操作**: 水泥厂信息的增删改查
- **地理位置查询**: 基于经纬度的空间查询
- **状态管理**: 支持active/inactive/under_construction三种状态
- **分页查询**: 大数据量下的高效分页

#### 数据模型
```java
@Entity
@Table(name = "cement_plants")
public class CementPlant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long plantId;
    
    @NotBlank(message = "水泥厂名称不能为空")
    @Size(max = 200, message = "水泥厂名称长度不能超过200字符")
    private String plantName;
    
    @NotNull(message = "经度不能为空")
    @DecimalMin(value = "-180.0", message = "经度范围无效")
    @DecimalMax(value = "180.0", message = "经度范围无效")
    private BigDecimal longitude;
    
    @NotNull(message = "纬度不能为空")
    @DecimalMin(value = "-90.0", message = "纬度范围无效")
    @DecimalMax(value = "90.0", message = "纬度范围无效")
    private BigDecimal latitude;
    
    private String province;
    private String city;
    private String district;
    
    @Enumerated(EnumType.STRING)
    private PlantStatus status = PlantStatus.ACTIVE;
    
    @CreationTimestamp
    private LocalDateTime createTime;
    
    @UpdateTimestamp
    private LocalDateTime updateTime;
}
```

### 1.2 技术实现

#### Controller层实现
```java
@RestController
@RequestMapping("/cement-plant")
@Validated
@Tag(name = "水泥厂管理", description = "水泥厂信息管理相关接口")
public class CementPlantController {
    
    @Autowired
    private CementPlantService cementPlantService;
    
    @GetMapping("/{plantId}")
    @Operation(summary = "根据ID查询水泥厂")
    public Result<CementPlant> getCementPlant(@PathVariable Long plantId) {
        CementPlant plant = cementPlantService.getById(plantId);
        return Result.success(plant);
    }
    
    @GetMapping("/page")
    @Operation(summary = "分页查询水泥厂")
    public Result<PageInfo<CementPlant>> getCementPlantPage(
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize,
            @RequestParam(required = false) String plantName,
            @RequestParam(required = false) String status) {
        
        PageInfo<CementPlant> pageInfo = cementPlantService.getPage(
            pageNum, pageSize, plantName, status);
        return Result.success(pageInfo);
    }
    
    @GetMapping("/location-range")
    @Operation(summary = "按地理位置范围查询")
    public Result<List<CementPlant>> getByLocationRange(
            @RequestParam BigDecimal minLng,
            @RequestParam BigDecimal maxLng,
            @RequestParam BigDecimal minLat,
            @RequestParam BigDecimal maxLat) {
        
        List<CementPlant> plants = cementPlantService.getByLocationRange(
            minLng, maxLng, minLat, maxLat);
        return Result.success(plants);
    }
}
```

#### Service层实现
```java
@Service
@Transactional
public class CementPlantServiceImpl implements CementPlantService {
    
    @Autowired
    private CementPlantMapper cementPlantMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CACHE_KEY_PREFIX = "cement_plant:";
    private static final String LIST_CACHE_KEY = "cement_plant:list";
    
    @Override
    @Cacheable(value = "cementPlant", key = "#plantId")
    public CementPlant getById(Long plantId) {
        // 先从Redis缓存获取
        String cacheKey = CACHE_KEY_PREFIX + plantId;
        CementPlant cached = (CementPlant) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 缓存未命中，从数据库查询
        CementPlant plant = cementPlantMapper.selectById(plantId);
        if (plant != null) {
            // 存入缓存，设置过期时间30分钟
            redisTemplate.opsForValue().set(cacheKey, plant, 30, TimeUnit.MINUTES);
        }
        return plant;
    }
    
    @Override
    public PageInfo<CementPlant> getPage(Integer pageNum, Integer pageSize, 
                                       String plantName, String status) {
        // 构建缓存key
        String cacheKey = String.format("%s:page:%d:%d:%s:%s", 
            LIST_CACHE_KEY, pageNum, pageSize, plantName, status);
        
        // 尝试从缓存获取
        PageInfo<CementPlant> cached = (PageInfo<CementPlant>) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 设置分页参数
        PageHelper.startPage(pageNum, pageSize);
        
        // 构建查询条件
        CementPlantQuery query = CementPlantQuery.builder()
            .plantName(plantName)
            .status(status)
            .build();
        
        List<CementPlant> plants = cementPlantMapper.selectByCondition(query);
        PageInfo<CementPlant> pageInfo = new PageInfo<>(plants);
        
        // 存入缓存，设置过期时间10分钟
        redisTemplate.opsForValue().set(cacheKey, pageInfo, 10, TimeUnit.MINUTES);
        
        return pageInfo;
    }
    
    @Override
    @CacheEvict(value = "cementPlant", key = "#plant.plantId")
    public void update(CementPlant plant) {
        cementPlantMapper.updateById(plant);
        
        // 清除相关缓存
        clearRelatedCache(plant.getPlantId());
    }
    
    private void clearRelatedCache(Long plantId) {
        // 清除单个对象缓存
        String cacheKey = CACHE_KEY_PREFIX + plantId;
        redisTemplate.delete(cacheKey);
        
        // 清除列表缓存（使用通配符删除）
        Set<String> keys = redisTemplate.keys(LIST_CACHE_KEY + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

#### Mapper层实现
```java
@Mapper
public interface CementPlantMapper {
    
    @Select("SELECT * FROM cement_plants WHERE plant_id = #{plantId}")
    CementPlant selectById(Long plantId);
    
    @SelectProvider(type = CementPlantSqlProvider.class, method = "selectByCondition")
    List<CementPlant> selectByCondition(CementPlantQuery query);
    
    @Select("SELECT * FROM cement_plants WHERE longitude BETWEEN #{minLng} AND #{maxLng} " +
            "AND latitude BETWEEN #{minLat} AND #{maxLat}")
    List<CementPlant> selectByLocationRange(@Param("minLng") BigDecimal minLng,
                                           @Param("maxLng") BigDecimal maxLng,
                                           @Param("minLat") BigDecimal minLat,
                                           @Param("maxLat") BigDecimal maxLat);
    
    @Insert("INSERT INTO cement_plants(plant_name, longitude, latitude, province, city, district, status) " +
            "VALUES(#{plantName}, #{longitude}, #{latitude}, #{province}, #{city}, #{district}, #{status})")
    @Options(useGeneratedKeys = true, keyProperty = "plantId")
    int insert(CementPlant plant);
    
    @Update("UPDATE cement_plants SET plant_name=#{plantName}, longitude=#{longitude}, " +
            "latitude=#{latitude}, province=#{province}, city=#{city}, district=#{district}, " +
            "status=#{status}, update_time=CURRENT_TIMESTAMP WHERE plant_id=#{plantId}")
    int updateById(CementPlant plant);
    
    @Delete("DELETE FROM cement_plants WHERE plant_id = #{plantId}")
    int deleteById(Long plantId);
}
```

---

## 2. 水泥厂识别记录管理模块

### 2.1 业务逻辑设计

#### 核心功能
- **识别记录管理**: 管理水泥厂的识别记录
- **NDVI指数**: 归一化植被指数分析
- **数据源管理**: 支持多种数据源
- **图像关联**: 通过UUID关联图像文件

#### 数据模型
```java
@Entity
@Table(name = "cement_plant_identifications")
public class CementPlantIdentification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long identificationId;
    
    @NotNull(message = "水泥厂ID不能为空")
    private Long plantId;
    
    private BigDecimal longitude;
    private BigDecimal latitude;
    
    @NotNull(message = "识别时间不能为空")
    private LocalDateTime identificationTime;
    
    @NotBlank(message = "数据源不能为空")
    private String dataSource;
    
    private String imageUuid;
    
    @DecimalMin(value = "-1.0", message = "NDVI指数范围无效")
    @DecimalMax(value = "1.0", message = "NDVI指数范围无效")
    private Float ndviIndex;
    
    private String province;
    private String city;
    private String district;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
}
```

### 2.2 技术实现

#### Service层实现
```java
@Service
@Transactional
public class CementPlantIdentificationServiceImpl implements CementPlantIdentificationService {
    
    @Autowired
    private CementPlantIdentificationMapper identificationMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    private static final String IDENTIFICATION_CACHE_PREFIX = "identification:";
    private static final String LATEST_IDENTIFICATION_KEY = "identification:latest";
    
    @Override
    public CementPlantIdentification getById(Long identificationId) {
        String cacheKey = IDENTIFICATION_CACHE_PREFIX + identificationId;
        
        // 先从缓存获取
        CementPlantIdentification cached = (CementPlantIdentification) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 从数据库查询
        CementPlantIdentification identification = identificationMapper.selectById(identificationId);
        if (identification != null) {
            // 存入缓存
            redisTemplate.opsForValue().set(cacheKey, identification, 20, TimeUnit.MINUTES);
        }
        
        return identification;
    }
    
    @Override
    public List<CementPlantIdentification> getLatestIdentifications(int limit) {
        String cacheKey = LATEST_IDENTIFICATION_KEY + ":" + limit;
        
        // 尝试从缓存获取
        List<CementPlantIdentification> cached = (List<CementPlantIdentification>) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 从数据库查询
        List<CementPlantIdentification> identifications = 
            identificationMapper.selectLatest(limit);
        
        // 存入缓存，设置过期时间5分钟
        redisTemplate.opsForValue().set(cacheKey, identifications, 5, TimeUnit.MINUTES);
        
        return identifications;
    }
    
    @Override
    public void batchInsert(List<CementPlantIdentification> identifications) {
        // 批量插入数据库
        identificationMapper.batchInsert(identifications);
        
        // 发送消息到队列进行后续处理
        IdentificationProcessMessage message = IdentificationProcessMessage.builder()
            .identificationIds(identifications.stream()
                .map(CementPlantIdentification::getIdentificationId)
                .collect(Collectors.toList()))
            .processType("BATCH_INSERT")
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend("identification.process.queue", message);
        
        // 清除相关缓存
        clearIdentificationCache();
    }
    
    private void clearIdentificationCache() {
        // 清除最新识别记录缓存
        Set<String> keys = redisTemplate.keys(LATEST_IDENTIFICATION_KEY + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
        
        // 清除分页缓存
        keys = redisTemplate.keys("identification:page:*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

---

## 3. 数据查询模块

### 3.1 业务逻辑设计

#### 核心功能
- **多维度查询**: 支持按名称、地区、地理位置、时间范围等查询
- **综合搜索**: 多条件组合查询
- **实时统计**: 提供数据统计和分析功能
- **查询优化**: 基于Redis的查询结果缓存

### 3.2 技术实现

#### Service层实现
```java
@Service
@Transactional(readOnly = true)
public class DataQueryServiceImpl implements DataQueryService {
    
    @Autowired
    private CementPlantMapper cementPlantMapper;
    
    @Autowired
    private CementPlantIdentificationMapper identificationMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String SEARCH_CACHE_PREFIX = "search:";
    private static final String STATS_CACHE_PREFIX = "stats:";
    
    @Override
    public List<CementPlant> searchCementPlants(SearchQuery query) {
        // 构建缓存key
        String cacheKey = buildSearchCacheKey(query);
        
        // 尝试从缓存获取
        List<CementPlant> cached = (List<CementPlant>) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 执行查询
        List<CementPlant> results = cementPlantMapper.searchByCondition(query);
        
        // 存入缓存，设置过期时间15分钟
        redisTemplate.opsForValue().set(cacheKey, results, 15, TimeUnit.MINUTES);
        
        return results;
    }
    
    @Override
    public List<CementPlantIdentification> searchIdentifications(IdentificationSearchQuery query) {
        String cacheKey = SEARCH_CACHE_PREFIX + "identification:" + 
            DigestUtils.md5Hex(query.toString());
        
        // 尝试从缓存获取
        List<CementPlantIdentification> cached = (List<CementPlantIdentification>) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 执行查询
        List<CementPlantIdentification> results = 
            identificationMapper.searchByCondition(query);
        
        // 存入缓存
        redisTemplate.opsForValue().set(cacheKey, results, 10, TimeUnit.MINUTES);
        
        return results;
    }
    
    @Override
    public QueryStatistics getQueryStatistics() {
        String cacheKey = STATS_CACHE_PREFIX + "query_stats";
        
        // 尝试从缓存获取
        QueryStatistics cached = (QueryStatistics) 
            redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 计算统计信息
        QueryStatistics stats = QueryStatistics.builder()
            .totalPlants(cementPlantMapper.countTotal())
            .totalIdentifications(identificationMapper.countTotal())
            .activePlants(cementPlantMapper.countByStatus("active"))
            .latestIdentificationTime(identificationMapper.getLatestTime())
            .build();
        
        // 存入缓存，设置过期时间1小时
        redisTemplate.opsForValue().set(cacheKey, stats, 1, TimeUnit.HOURS);
        
        return stats;
    }
    
    private String buildSearchCacheKey(SearchQuery query) {
        return SEARCH_CACHE_PREFIX + "cement_plant:" + 
            DigestUtils.md5Hex(query.toString());
    }
}
```

---

## 4. 数据上传模块

### 4.1 业务逻辑设计

#### 核心功能
- **权限控制**: 仅管理员可上传数据
- **数据验证**: JSON格式和业务规则验证
- **批量处理**: 支持批量上传和错误处理
- **异步处理**: 大文件异步上传处理

### 4.2 技术实现

#### Service层实现
```java
@Service
@Transactional
public class DataUploadServiceImpl implements DataUploadService {
    
    @Autowired
    private CementPlantMapper cementPlantMapper;
    
    @Autowired
    private CementPlantIdentificationMapper identificationMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    private static final String UPLOAD_STATUS_PREFIX = "upload:status:";
    private static final String UPLOAD_LOCK_PREFIX = "upload:lock:";
    
    @Override
    public UploadResult uploadCementPlantData(CementPlantDataUploadRequest request, 
                                            String username) {
        // 检查权限
        if (!hasUploadPermission(username)) {
            throw new BusinessException("无上传权限");
        }
        
        // 生成上传任务ID
        String taskId = UUID.randomUUID().toString();
        
        // 设置上传状态
        UploadStatus status = UploadStatus.builder()
            .taskId(taskId)
            .status("PROCESSING")
            .totalCount(request.getData().size())
            .processedCount(0)
            .errorCount(0)
            .startTime(LocalDateTime.now())
            .build();
        
        redisTemplate.opsForValue().set(UPLOAD_STATUS_PREFIX + taskId, status, 
            2, TimeUnit.HOURS);
        
        // 发送异步处理消息
        DataUploadMessage message = DataUploadMessage.builder()
            .taskId(taskId)
            .data(request.getData())
            .username(username)
            .uploadType("CEMENT_PLANT_DATA")
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend("data.upload.queue", message);
        
        return UploadResult.builder()
            .taskId(taskId)
            .status("PROCESSING")
            .message("上传任务已提交，正在处理中")
            .build();
    }
    
    @Override
    public UploadStatus getUploadStatus(String taskId) {
        String cacheKey = UPLOAD_STATUS_PREFIX + taskId;
        UploadStatus status = (UploadStatus) redisTemplate.opsForValue().get(cacheKey);
        
        if (status == null) {
            throw new BusinessException("上传任务不存在或已过期");
        }
        
        return status;
    }
    
    @RabbitListener(queues = "data.upload.queue")
    public void processDataUpload(DataUploadMessage message) {
        String taskId = message.getTaskId();
        String lockKey = UPLOAD_LOCK_PREFIX + taskId;
        
        // 获取分布式锁
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "locked", 30, TimeUnit.MINUTES);
        
        if (!lockAcquired) {
            log.warn("上传任务 {} 正在处理中，跳过", taskId);
            return;
        }
        
        try {
            processUploadData(message);
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey);
        }
    }
    
    private void processUploadData(DataUploadMessage message) {
        String taskId = message.getTaskId();
        UploadStatus status = getUploadStatus(taskId);
        
        try {
            List<CementPlantData> dataList = message.getData();
            int processedCount = 0;
            int errorCount = 0;
            
            for (CementPlantData data : dataList) {
                try {
                    // 处理单条数据
                    processSingleData(data, message.getUsername());
                    processedCount++;
                    
                    // 更新进度
                    status.setProcessedCount(processedCount);
                    redisTemplate.opsForValue().set(UPLOAD_STATUS_PREFIX + taskId, status, 
                        2, TimeUnit.HOURS);
                    
                } catch (Exception e) {
                    errorCount++;
                    log.error("处理数据失败: {}", e.getMessage(), e);
                }
            }
            
            // 更新最终状态
            status.setStatus("COMPLETED");
            status.setErrorCount(errorCount);
            status.setEndTime(LocalDateTime.now());
            redisTemplate.opsForValue().set(UPLOAD_STATUS_PREFIX + taskId, status, 
                24, TimeUnit.HOURS);
            
        } catch (Exception e) {
            // 更新失败状态
            status.setStatus("FAILED");
            status.setErrorMessage(e.getMessage());
            status.setEndTime(LocalDateTime.now());
            redisTemplate.opsForValue().set(UPLOAD_STATUS_PREFIX + taskId, status, 
                24, TimeUnit.HOURS);
            
            log.error("上传处理失败: {}", e.getMessage(), e);
        }
    }
    
    private void processSingleData(CementPlantData data, String username) {
        // 检查水泥厂是否存在
        CementPlant existingPlant = cementPlantMapper.selectByName(data.getPlantName());
        
        if (existingPlant == null) {
            // 创建新水泥厂
            CementPlant newPlant = CementPlant.builder()
                .plantName(data.getPlantName())
                .longitude(data.getLongitude())
                .latitude(data.getLatitude())
                .province(data.getProvince())
                .city(data.getCity())
                .district(data.getDistrict())
                .status(PlantStatus.ACTIVE)
                .build();
            
            cementPlantMapper.insert(newPlant);
            existingPlant = newPlant;
        }
        
        // 创建识别记录
        CementPlantIdentification identification = CementPlantIdentification.builder()
            .plantId(existingPlant.getPlantId())
            .longitude(data.getLongitude())
            .latitude(data.getLatitude())
            .identificationTime(data.getIdentificationTime())
            .dataSource(data.getDataSource())
            .imageUuid(data.getImageUuid())
            .ndviIndex(data.getNdviIndex())
            .province(data.getProvince())
            .city(data.getCity())
            .district(data.getDistrict())
            .build();
        
        identificationMapper.insert(identification);
    }
    
    private boolean hasUploadPermission(String username) {
        // 检查用户权限
        String permissionKey = "user:permission:" + username;
        Integer roleCode = (Integer) redisTemplate.opsForValue().get(permissionKey);
        
        if (roleCode == null) {
            // 从数据库查询用户权限
            User user = userMapper.selectByUsername(username);
            if (user != null) {
                roleCode = user.getRoleCode();
                redisTemplate.opsForValue().set(permissionKey, roleCode, 30, TimeUnit.MINUTES);
            }
        }
        
        return roleCode != null && roleCode == 0; // 0表示管理员
    }
}
```

---

## 5. 数据下载模块

### 5.1 业务逻辑设计

#### 核心功能
- **权限控制**: 基于用户角色的下载权限
- **配额管理**: 每日下载次数限制
- **异步下载**: 大文件异步下载处理
- **批量下载**: ZIP格式打包下载

### 5.2 技术实现

#### Service层实现
```java
@Service
@Transactional
public class DataDownloadServiceImpl implements DataDownloadService {
    
    @Autowired
    private GeospatialFileMapper fileMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    private static final String DOWNLOAD_QUOTA_PREFIX = "download:quota:";
    private static final String DOWNLOAD_STATUS_PREFIX = "download:status:";
    private static final String DOWNLOAD_HISTORY_PREFIX = "download:history:";
    
    @Override
    public DownloadResult downloadTifFile(Long fileId, String username) {
        // 检查下载权限
        if (!hasDownloadPermission(username)) {
            throw new BusinessException("无下载权限");
        }
        
        // 检查下载配额
        if (!checkDownloadQuota(username)) {
            throw new BusinessException("今日下载次数已达上限");
        }
        
        // 查询文件信息
        GeospatialFile file = fileMapper.selectById(fileId);
        if (file == null) {
            throw new BusinessException("文件不存在");
        }
        
        // 生成下载任务ID
        String taskId = UUID.randomUUID().toString();
        
        // 创建下载任务
        DownloadTask task = DownloadTask.builder()
            .taskId(taskId)
            .fileId(fileId)
            .fileName(file.getFileName())
            .filePath(file.getFilePath())
            .username(username)
            .status("PENDING")
            .createTime(LocalDateTime.now())
            .build();
        
        // 存储任务信息
        redisTemplate.opsForValue().set(DOWNLOAD_STATUS_PREFIX + taskId, task, 
            24, TimeUnit.HOURS);
        
        // 发送异步下载消息
        DownloadMessage message = DownloadMessage.builder()
            .taskId(taskId)
            .fileId(fileId)
            .filePath(file.getFilePath())
            .username(username)
            .downloadType("SINGLE_FILE")
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend("data.download.queue", message);
        
        // 更新下载配额
        updateDownloadQuota(username);
        
        // 记录下载历史
        recordDownloadHistory(username, fileId, taskId);
        
        return DownloadResult.builder()
            .taskId(taskId)
            .status("PENDING")
            .message("下载任务已提交")
            .build();
    }
    
    @Override
    public DownloadResult batchDownload(List<Long> fileIds, String username) {
        // 检查下载权限
        if (!hasDownloadPermission(username)) {
            throw new BusinessException("无下载权限");
        }
        
        // 检查批量下载配额
        if (!checkBatchDownloadQuota(username, fileIds.size())) {
            throw new BusinessException("批量下载数量超出限制");
        }
        
        // 生成批量下载任务ID
        String taskId = UUID.randomUUID().toString();
        
        // 创建批量下载任务
        BatchDownloadTask task = BatchDownloadTask.builder()
            .taskId(taskId)
            .fileIds(fileIds)
            .username(username)
            .status("PENDING")
            .totalCount(fileIds.size())
            .processedCount(0)
            .createTime(LocalDateTime.now())
            .build();
        
        // 存储任务信息
        redisTemplate.opsForValue().set(DOWNLOAD_STATUS_PREFIX + taskId, task, 
            24, TimeUnit.HOURS);
        
        // 发送批量下载消息
        BatchDownloadMessage message = BatchDownloadMessage.builder()
            .taskId(taskId)
            .fileIds(fileIds)
            .username(username)
            .downloadType("BATCH_DOWNLOAD")
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend("data.batch.download.queue", message);
        
        // 更新下载配额
        updateDownloadQuota(username, fileIds.size());
        
        return DownloadResult.builder()
            .taskId(taskId)
            .status("PENDING")
            .message("批量下载任务已提交")
            .build();
    }
    
    @RabbitListener(queues = "data.download.queue")
    public void processDownload(DownloadMessage message) {
        String taskId = message.getTaskId();
        
        try {
            // 更新任务状态
            updateDownloadTaskStatus(taskId, "PROCESSING");
            
            // 执行文件下载
            File file = new File(message.getFilePath());
            if (!file.exists()) {
                throw new FileNotFoundException("文件不存在: " + message.getFilePath());
            }
            
            // 生成下载链接
            String downloadUrl = generateDownloadUrl(file, taskId);
            
            // 更新任务状态为完成
            DownloadTask task = (DownloadTask) redisTemplate.opsForValue()
                .get(DOWNLOAD_STATUS_PREFIX + taskId);
            task.setStatus("COMPLETED");
            task.setDownloadUrl(downloadUrl);
            task.setCompleteTime(LocalDateTime.now());
            
            redisTemplate.opsForValue().set(DOWNLOAD_STATUS_PREFIX + taskId, task, 
                24, TimeUnit.HOURS);
            
        } catch (Exception e) {
            // 更新任务状态为失败
            updateDownloadTaskStatus(taskId, "FAILED", e.getMessage());
            log.error("下载处理失败: {}", e.getMessage(), e);
        }
    }
    
    @RabbitListener(queues = "data.batch.download.queue")
    public void processBatchDownload(BatchDownloadMessage message) {
        String taskId = message.getTaskId();
        
        try {
            // 更新任务状态
            updateBatchDownloadTaskStatus(taskId, "PROCESSING");
            
            // 创建临时目录
            String tempDir = System.getProperty("java.io.tmpdir") + "/batch_download/" + taskId;
            Files.createDirectories(Paths.get(tempDir));
            
            // 下载所有文件
            List<String> downloadedFiles = new ArrayList<>();
            for (Long fileId : message.getFileIds()) {
                GeospatialFile file = fileMapper.selectById(fileId);
                if (file != null) {
                    String destPath = tempDir + "/" + file.getFileName();
                    Files.copy(Paths.get(file.getFilePath()), Paths.get(destPath));
                    downloadedFiles.add(destPath);
                }
            }
            
            // 创建ZIP文件
            String zipPath = tempDir + "/batch_download_" + taskId + ".zip";
            createZipFile(downloadedFiles, zipPath);
            
            // 生成下载链接
            String downloadUrl = generateDownloadUrl(new File(zipPath), taskId);
            
            // 更新任务状态
            BatchDownloadTask task = (BatchDownloadTask) redisTemplate.opsForValue()
                .get(DOWNLOAD_STATUS_PREFIX + taskId);
            task.setStatus("COMPLETED");
            task.setDownloadUrl(downloadUrl);
            task.setCompleteTime(LocalDateTime.now());
            
            redisTemplate.opsForValue().set(DOWNLOAD_STATUS_PREFIX + taskId, task, 
                24, TimeUnit.HOURS);
            
        } catch (Exception e) {
            updateBatchDownloadTaskStatus(taskId, "FAILED", e.getMessage());
            log.error("批量下载处理失败: {}", e.getMessage(), e);
        }
    }
    
    private boolean checkDownloadQuota(String username) {
        String quotaKey = DOWNLOAD_QUOTA_PREFIX + username + ":" + LocalDate.now();
        Integer count = (Integer) redisTemplate.opsForValue().get(quotaKey);
        
        if (count == null) {
            count = 0;
        }
        
        // 每日下载限制为100次
        return count < 100;
    }
    
    private void updateDownloadQuota(String username) {
        String quotaKey = DOWNLOAD_QUOTA_PREFIX + username + ":" + LocalDate.now();
        redisTemplate.opsForValue().increment(quotaKey);
        redisTemplate.expire(quotaKey, 1, TimeUnit.DAYS);
    }
    
    private void recordDownloadHistory(String username, Long fileId, String taskId) {
        DownloadHistory history = DownloadHistory.builder()
            .username(username)
            .fileId(fileId)
            .taskId(taskId)
            .downloadTime(LocalDateTime.now())
            .build();
        
        String historyKey = DOWNLOAD_HISTORY_PREFIX + username;
        redisTemplate.opsForList().leftPush(historyKey, history);
        redisTemplate.opsForList().trim(historyKey, 0, 99); // 保留最近100条记录
        redisTemplate.expire(historyKey, 30, TimeUnit.DAYS);
    }
}
```

---

## 6. 地理数据管理模块

### 6.1 业务逻辑设计

#### 核心功能
- **TIF文件处理**: 专业的地理数据处理
- **瓦片服务**: 提供地图瓦片服务
- **异步处理**: 大文件异步处理
- **缓存机制**: 瓦片数据缓存

### 6.2 技术实现

#### Service层实现
```java
@Service
@Transactional
public class GeospatialDataServiceImpl implements GeospatialDataService {
    
    @Autowired
    private GeospatialFileMapper fileMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    private static final String TILE_CACHE_PREFIX = "tile:";
    private static final String FILE_PROCESSING_PREFIX = "file:processing:";
    
    @Override
    public UploadResult uploadTifFile(MultipartFile file, String username) {
        // 检查文件格式
        if (!file.getOriginalFilename().toLowerCase().endsWith(".tif")) {
            throw new BusinessException("仅支持TIF格式文件");
        }
        
        // 检查文件大小（限制100MB）
        if (file.getSize() > 100 * 1024 * 1024) {
            throw new BusinessException("文件大小不能超过100MB");
        }
        
        // 生成文件ID
        Long fileId = generateFileId();
        
        // 保存文件
        String fileName = fileId + "_" + file.getOriginalFilename();
        String filePath = saveFile(file, fileName);
        
        // 创建文件记录
        GeospatialFile geospatialFile = GeospatialFile.builder()
            .fileId(fileId)
            .fileName(fileName)
            .filePath(filePath)
            .fileType("TIF")
            .fileSize(file.getSize())
            .status("UPLOADED")
            .build();
        
        fileMapper.insert(geospatialFile);
        
        // 发送异步处理消息
        TifProcessMessage message = TifProcessMessage.builder()
            .fileId(fileId)
            .filePath(filePath)
            .fileName(fileName)
            .username(username)
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend("tif.process.queue", message);
        
        return UploadResult.builder()
            .fileId(fileId)
            .status("UPLOADED")
            .message("文件上传成功，正在处理中")
            .build();
    }
    
    @Override
    public byte[] getTile(Long fileId, int z, int x, int y) {
        // 构建缓存key
        String cacheKey = TILE_CACHE_PREFIX + fileId + ":" + z + ":" + x + ":" + y;
        
        // 尝试从缓存获取
        byte[] cachedTile = (byte[]) redisTemplate.opsForValue().get(cacheKey);
        if (cachedTile != null) {
            return cachedTile;
        }
        
        // 从文件生成瓦片
        byte[] tile = generateTile(fileId, z, x, y);
        
        if (tile != null) {
            // 存入缓存，设置过期时间24小时
            redisTemplate.opsForValue().set(cacheKey, tile, 24, TimeUnit.HOURS);
        }
        
        return tile;
    }
    
    @RabbitListener(queues = "tif.process.queue")
    public void processTifFile(TifProcessMessage message) {
        Long fileId = message.getFileId();
        String processingKey = FILE_PROCESSING_PREFIX + fileId;
        
        // 获取处理锁
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(processingKey, "processing", 2, TimeUnit.HOURS);
        
        if (!lockAcquired) {
            log.warn("文件 {} 正在处理中，跳过", fileId);
            return;
        }
        
        try {
            // 更新文件状态
            updateFileStatus(fileId, "PROCESSING");
            
            // 处理TIF文件
            processTifFileInternal(message.getFilePath());
            
            // 更新文件状态为完成
            updateFileStatus(fileId, "COMPLETED");
            
        } catch (Exception e) {
            // 更新文件状态为失败
            updateFileStatus(fileId, "FAILED", e.getMessage());
            log.error("TIF文件处理失败: {}", e.getMessage(), e);
        } finally {
            // 释放处理锁
            redisTemplate.delete(processingKey);
        }
    }
    
    private void processTifFileInternal(String filePath) {
        try {
            // 使用GDAL或其他地理数据处理库处理TIF文件
            // 这里简化处理，实际应该使用专业的地理数据处理库
            
            File file = new File(filePath);
            if (!file.exists()) {
                throw new FileNotFoundException("文件不存在: " + filePath);
            }
            
            // 模拟处理过程
            Thread.sleep(5000); // 模拟处理时间
            
            // 实际处理逻辑：
            // 1. 读取TIF文件元数据
            // 2. 生成瓦片金字塔
            // 3. 创建索引文件
            // 4. 验证文件完整性
            
        } catch (Exception e) {
            throw new RuntimeException("TIF文件处理失败", e);
        }
    }
    
    private byte[] generateTile(Long fileId, int z, int x, int y) {
        // 从TIF文件生成指定瓦片
        // 这里简化实现，实际应该使用专业的地理数据处理库
        
        try {
            // 模拟瓦片生成
            BufferedImage tile = new BufferedImage(256, 256, BufferedImage.TYPE_INT_RGB);
            Graphics2D g2d = tile.createGraphics();
            g2d.setColor(Color.WHITE);
            g2d.fillRect(0, 0, 256, 256);
            g2d.setColor(Color.BLACK);
            g2d.drawString("Tile " + z + "/" + x + "/" + y, 10, 20);
            g2d.dispose();
            
            // 转换为字节数组
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ImageIO.write(tile, "PNG", baos);
            return baos.toByteArray();
            
        } catch (Exception e) {
            log.error("生成瓦片失败: {}", e.getMessage(), e);
            return null;
        }
    }
    
    private void updateFileStatus(Long fileId, String status) {
        updateFileStatus(fileId, status, null);
    }
    
    private void updateFileStatus(Long fileId, String status, String errorMessage) {
        GeospatialFile file = fileMapper.selectById(fileId);
        if (file != null) {
            file.setStatus(status);
            if (errorMessage != null) {
                file.setErrorMessage(errorMessage);
            }
            file.setUpdateTime(LocalDateTime.now());
            fileMapper.updateById(file);
        }
    }
}
```

---

## Redis 应用详解

### Redis 在系统中的核心作用

#### 1. 缓存层设计

##### 缓存策略
```java
@Configuration
@EnableCaching
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 设置序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        template.afterPropertiesSet();
        return template;
    }
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

##### 缓存应用场景

**1. 用户会话管理**
```java
@Service
public class UserSessionService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String SESSION_PREFIX = "session:";
    private static final String USER_PERMISSION_PREFIX = "user:permission:";
    
    public void createSession(String username, String token) {
        UserSession session = UserSession.builder()
            .username(username)
            .token(token)
            .loginTime(LocalDateTime.now())
            .lastAccessTime(LocalDateTime.now())
            .build();
        
        // 存储会话信息，过期时间2小时
        redisTemplate.opsForValue().set(SESSION_PREFIX + token, session, 2, TimeUnit.HOURS);
        
        // 存储用户权限，过期时间30分钟
        User user = userMapper.selectByUsername(username);
        redisTemplate.opsForValue().set(USER_PERMISSION_PREFIX + username, 
            user.getRoleCode(), 30, TimeUnit.MINUTES);
    }
    
    public UserSession getSession(String token) {
        return (UserSession) redisTemplate.opsForValue().get(SESSION_PREFIX + token);
    }
    
    public void updateLastAccessTime(String token) {
        UserSession session = getSession(token);
        if (session != null) {
            session.setLastAccessTime(LocalDateTime.now());
            redisTemplate.opsForValue().set(SESSION_PREFIX + token, session, 2, TimeUnit.HOURS);
        }
    }
}
```

**2. 查询结果缓存**
```java
@Service
public class QueryCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String QUERY_CACHE_PREFIX = "query:";
    
    public <T> T getCachedResult(String cacheKey, Class<T> type) {
        return (T) redisTemplate.opsForValue().get(QUERY_CACHE_PREFIX + cacheKey);
    }
    
    public void cacheResult(String cacheKey, Object result, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(QUERY_CACHE_PREFIX + cacheKey, result, timeout, unit);
    }
    
    public void invalidateCache(String pattern) {
        Set<String> keys = redisTemplate.keys(QUERY_CACHE_PREFIX + pattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

**3. 瓦片数据缓存**
```java
@Service
public class TileCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String TILE_CACHE_PREFIX = "tile:";
    
    public byte[] getTile(Long fileId, int z, int x, int y) {
        String cacheKey = TILE_CACHE_PREFIX + fileId + ":" + z + ":" + x + ":" + y;
        return (byte[]) redisTemplate.opsForValue().get(cacheKey);
    }
    
    public void cacheTile(Long fileId, int z, int x, int y, byte[] tileData) {
        String cacheKey = TILE_CACHE_PREFIX + fileId + ":" + z + ":" + x + ":" + y;
        // 瓦片数据缓存24小时
        redisTemplate.opsForValue().set(cacheKey, tileData, 24, TimeUnit.HOURS);
    }
    
    public void clearTileCache(Long fileId) {
        String pattern = TILE_CACHE_PREFIX + fileId + ":*";
        Set<String> keys = redisTemplate.keys(pattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

#### 2. 分布式锁实现

```java
@Service
public class DistributedLockService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public boolean acquireLock(String lockKey, String lockValue, long timeout, TimeUnit unit) {
        Boolean acquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, timeout, unit);
        return acquired != null && acquired;
    }
    
    public void releaseLock(String lockKey, String lockValue) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) else return 0 end";
        
        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
            Collections.singletonList(lockKey), lockValue);
    }
    
    public boolean tryLock(String lockKey, String lockValue, long waitTime, long leaseTime, TimeUnit unit) {
        long endTime = System.currentTimeMillis() + unit.toMillis(waitTime);
        
        while (System.currentTimeMillis() < endTime) {
            if (acquireLock(lockKey, lockValue, leaseTime, unit)) {
                return true;
            }
            
            try {
                Thread.sleep(100); // 等待100ms后重试
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        return false;
    }
}
```

#### 3. 限流和配额管理

```java
@Service
public class RateLimitService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public boolean isAllowed(String key, int limit, long windowSize, TimeUnit unit) {
        String script = 
            "local current = redis.call('get', KEYS[1]) " +
            "if current == false then " +
            "  redis.call('set', KEYS[1], 1) " +
            "  redis.call('expire', KEYS[1], ARGV[1]) " +
            "  return 1 " +
            "else " +
            "  local count = redis.call('incr', KEYS[1]) " +
            "  if count <= tonumber(ARGV[2]) then " +
            "    return 1 " +
            "  else " +
            "    return 0 " +
            "  end " +
            "end";
        
        Long result = redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key), 
            String.valueOf(unit.toSeconds(windowSize)), 
            String.valueOf(limit));
        
        return result != null && result == 1;
    }
    
    public boolean checkDownloadQuota(String username) {
        String quotaKey = "download:quota:" + username + ":" + LocalDate.now();
        return isAllowed(quotaKey, 100, 1, TimeUnit.DAYS);
    }
    
    public boolean checkUploadQuota(String username) {
        String quotaKey = "upload:quota:" + username + ":" + LocalDate.now();
        return isAllowed(quotaKey, 50, 1, TimeUnit.DAYS);
    }
}
```

---

## RabbitMQ 应用详解

### RabbitMQ 在系统中的核心作用

#### 1. 消息队列配置

```java
@Configuration
@EnableRabbit
public class RabbitMQConfig {
    
    // 数据上传队列
    @Bean
    public Queue dataUploadQueue() {
        return QueueBuilder.durable("data.upload.queue")
            .withArgument("x-message-ttl", 3600000) // 1小时TTL
            .withArgument("x-max-retries", 3) // 最大重试3次
            .build();
    }
    
    // 数据下载队列
    @Bean
    public Queue dataDownloadQueue() {
        return QueueBuilder.durable("data.download.queue")
            .withArgument("x-message-ttl", 7200000) // 2小时TTL
            .build();
    }
    
    // 批量下载队列
    @Bean
    public Queue batchDownloadQueue() {
        return QueueBuilder.durable("data.batch.download.queue")
            .withArgument("x-message-ttl", 14400000) // 4小时TTL
            .build();
    }
    
    // TIF文件处理队列
    @Bean
    public Queue tifProcessQueue() {
        return QueueBuilder.durable("tif.process.queue")
            .withArgument("x-message-ttl", 28800000) // 8小时TTL
            .build();
    }
    
    // 识别记录处理队列
    @Bean
    public Queue identificationProcessQueue() {
        return QueueBuilder.durable("identification.process.queue")
            .withArgument("x-message-ttl", 1800000) // 30分钟TTL
            .build();
    }
    
    // 死信队列
    @Bean
    public Queue deadLetterQueue() {
        return QueueBuilder.durable("dead.letter.queue").build();
    }
    
    // 死信交换机
    @Bean
    public DirectExchange deadLetterExchange() {
        return new DirectExchange("dead.letter.exchange");
    }
    
    @Bean
    public Binding deadLetterBinding() {
        return BindingBuilder.bind(deadLetterQueue())
            .to(deadLetterExchange())
            .with("dead.letter");
    }
}
```

#### 2. 异步消息处理

##### 数据上传消息处理
```java
@Component
@Slf4j
public class DataUploadMessageHandler {
    
    @Autowired
    private CementPlantMapper cementPlantMapper;
    
    @Autowired
    private CementPlantIdentificationMapper identificationMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @RabbitListener(queues = "data.upload.queue", concurrency = "3-5")
    public void handleDataUpload(DataUploadMessage message) {
        String taskId = message.getTaskId();
        log.info("开始处理数据上传任务: {}", taskId);
        
        try {
            // 更新任务状态
            updateTaskStatus(taskId, "PROCESSING");
            
            // 处理数据
            processUploadData(message);
            
            // 更新任务状态为完成
            updateTaskStatus(taskId, "COMPLETED");
            
            log.info("数据上传任务处理完成: {}", taskId);
            
        } catch (Exception e) {
            log.error("数据上传任务处理失败: {}", taskId, e);
            updateTaskStatus(taskId, "FAILED", e.getMessage());
            
            // 发送到死信队列
            throw new AmqpRejectAndDontRequeueException("处理失败", e);
        }
    }
    
    private void processUploadData(DataUploadMessage message) {
        List<CementPlantData> dataList = message.getData();
        int processedCount = 0;
        int errorCount = 0;
        
        for (CementPlantData data : dataList) {
            try {
                processSingleData(data);
                processedCount++;
                
                // 更新进度
                updateProgress(message.getTaskId(), processedCount, dataList.size());
                
            } catch (Exception e) {
                errorCount++;
                log.error("处理单条数据失败: {}", e.getMessage(), e);
            }
        }
        
        log.info("数据上传处理完成，成功: {}, 失败: {}", processedCount, errorCount);
    }
    
    private void processSingleData(CementPlantData data) {
        // 检查水泥厂是否存在
        CementPlant existingPlant = cementPlantMapper.selectByName(data.getPlantName());
        
        if (existingPlant == null) {
            // 创建新水泥厂
            CementPlant newPlant = CementPlant.builder()
                .plantName(data.getPlantName())
                .longitude(data.getLongitude())
                .latitude(data.getLatitude())
                .province(data.getProvince())
                .city(data.getCity())
                .district(data.getDistrict())
                .status(PlantStatus.ACTIVE)
                .build();
            
            cementPlantMapper.insert(newPlant);
            existingPlant = newPlant;
        }
        
        // 创建识别记录
        CementPlantIdentification identification = CementPlantIdentification.builder()
            .plantId(existingPlant.getPlantId())
            .longitude(data.getLongitude())
            .latitude(data.getLatitude())
            .identificationTime(data.getIdentificationTime())
            .dataSource(data.getDataSource())
            .imageUuid(data.getImageUuid())
            .ndviIndex(data.getNdviIndex())
            .province(data.getProvince())
            .city(data.getCity())
            .district(data.getDistrict())
            .build();
        
        identificationMapper.insert(identification);
    }
    
    private void updateTaskStatus(String taskId, String status) {
        updateTaskStatus(taskId, status, null);
    }
    
    private void updateTaskStatus(String taskId, String status, String errorMessage) {
        String statusKey = "upload:status:" + taskId;
        UploadStatus statusObj = (UploadStatus) redisTemplate.opsForValue().get(statusKey);
        
        if (statusObj != null) {
            statusObj.setStatus(status);
            if (errorMessage != null) {
                statusObj.setErrorMessage(errorMessage);
            }
            statusObj.setEndTime(LocalDateTime.now());
            
            redisTemplate.opsForValue().set(statusKey, statusObj, 24, TimeUnit.HOURS);
        }
    }
    
    private void updateProgress(String taskId, int processed, int total) {
        String statusKey = "upload:status:" + taskId;
        UploadStatus statusObj = (UploadStatus) redisTemplate.opsForValue().get(statusKey);
        
        if (statusObj != null) {
            statusObj.setProcessedCount(processed);
            statusObj.setProgress((double) processed / total * 100);
            
            redisTemplate.opsForValue().set(statusKey, statusObj, 24, TimeUnit.HOURS);
        }
    }
}
```

##### 数据下载消息处理
```java
@Component
@Slf4j
public class DataDownloadMessageHandler {
    
    @Autowired
    private GeospatialFileMapper fileMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @RabbitListener(queues = "data.download.queue", concurrency = "2-4")
    public void handleDataDownload(DownloadMessage message) {
        String taskId = message.getTaskId();
        log.info("开始处理数据下载任务: {}", taskId);
        
        try {
            // 更新任务状态
            updateDownloadTaskStatus(taskId, "PROCESSING");
            
            // 执行下载
            String downloadUrl = executeDownload(message);
            
            // 更新任务状态为完成
            updateDownloadTaskStatus(taskId, "COMPLETED", downloadUrl);
            
            log.info("数据下载任务处理完成: {}", taskId);
            
        } catch (Exception e) {
            log.error("数据下载任务处理失败: {}", taskId, e);
            updateDownloadTaskStatus(taskId, "FAILED", e.getMessage());
            
            throw new AmqpRejectAndDontRequeueException("下载失败", e);
        }
    }
    
    @RabbitListener(queues = "data.batch.download.queue", concurrency = "1-2")
    public void handleBatchDownload(BatchDownloadMessage message) {
        String taskId = message.getTaskId();
        log.info("开始处理批量下载任务: {}", taskId);
        
        try {
            // 更新任务状态
            updateBatchDownloadTaskStatus(taskId, "PROCESSING");
            
            // 执行批量下载
            String downloadUrl = executeBatchDownload(message);
            
            // 更新任务状态为完成
            updateBatchDownloadTaskStatus(taskId, "COMPLETED", downloadUrl);
            
            log.info("批量下载任务处理完成: {}", taskId);
            
        } catch (Exception e) {
            log.error("批量下载任务处理失败: {}", taskId, e);
            updateBatchDownloadTaskStatus(taskId, "FAILED", e.getMessage());
            
            throw new AmqpRejectAndDontRequeueException("批量下载失败", e);
        }
    }
    
    private String executeDownload(DownloadMessage message) throws IOException {
        GeospatialFile file = fileMapper.selectById(message.getFileId());
        if (file == null) {
            throw new FileNotFoundException("文件不存在");
        }
        
        // 创建下载链接
        String downloadUrl = generateDownloadUrl(file.getFilePath(), message.getTaskId());
        
        // 记录下载历史
        recordDownloadHistory(message.getUsername(), message.getFileId(), message.getTaskId());
        
        return downloadUrl;
    }
    
    private String executeBatchDownload(BatchDownloadMessage message) throws IOException {
        // 创建临时目录
        String tempDir = System.getProperty("java.io.tmpdir") + "/batch_download/" + message.getTaskId();
        Files.createDirectories(Paths.get(tempDir));
        
        // 下载所有文件
        List<String> downloadedFiles = new ArrayList<>();
        for (Long fileId : message.getFileIds()) {
            GeospatialFile file = fileMapper.selectById(fileId);
            if (file != null) {
                String destPath = tempDir + "/" + file.getFileName();
                Files.copy(Paths.get(file.getFilePath()), Paths.get(destPath));
                downloadedFiles.add(destPath);
            }
        }
        
        // 创建ZIP文件
        String zipPath = tempDir + "/batch_download_" + message.getTaskId() + ".zip";
        createZipFile(downloadedFiles, zipPath);
        
        // 生成下载链接
        String downloadUrl = generateDownloadUrl(zipPath, message.getTaskId());
        
        // 记录下载历史
        recordBatchDownloadHistory(message.getUsername(), message.getFileIds(), message.getTaskId());
        
        return downloadUrl;
    }
    
    private void createZipFile(List<String> files, String zipPath) throws IOException {
        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath))) {
            for (String filePath : files) {
                File file = new File(filePath);
                ZipEntry entry = new ZipEntry(file.getName());
                zos.putNextEntry(entry);
                
                try (FileInputStream fis = new FileInputStream(file)) {
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = fis.read(buffer)) > 0) {
                        zos.write(buffer, 0, length);
                    }
                }
                
                zos.closeEntry();
            }
        }
    }
    
    private String generateDownloadUrl(String filePath, String taskId) {
        // 生成临时下载链接
        return "/api/download/temp/" + taskId + "/" + new File(filePath).getName();
    }
    
    private void updateDownloadTaskStatus(String taskId, String status) {
        updateDownloadTaskStatus(taskId, status, null);
    }
    
    private void updateDownloadTaskStatus(String taskId, String status, String downloadUrl) {
        String statusKey = "download:status:" + taskId;
        DownloadTask task = (DownloadTask) redisTemplate.opsForValue().get(statusKey);
        
        if (task != null) {
            task.setStatus(status);
            if (downloadUrl != null) {
                task.setDownloadUrl(downloadUrl);
            }
            task.setCompleteTime(LocalDateTime.now());
            
            redisTemplate.opsForValue().set(statusKey, task, 24, TimeUnit.HOURS);
        }
    }
    
    private void updateBatchDownloadTaskStatus(String taskId, String status) {
        updateBatchDownloadTaskStatus(taskId, status, null);
    }
    
    private void updateBatchDownloadTaskStatus(String taskId, String status, String downloadUrl) {
        String statusKey = "download:status:" + taskId;
        BatchDownloadTask task = (BatchDownloadTask) redisTemplate.opsForValue().get(statusKey);
        
        if (task != null) {
            task.setStatus(status);
            if (downloadUrl != null) {
                task.setDownloadUrl(downloadUrl);
            }
            task.setCompleteTime(LocalDateTime.now());
            
            redisTemplate.opsForValue().set(statusKey, task, 24, TimeUnit.HOURS);
        }
    }
}
```

##### TIF文件处理消息处理
```java
@Component
@Slf4j
public class TifProcessMessageHandler {
    
    @Autowired
    private GeospatialFileMapper fileMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @RabbitListener(queues = "tif.process.queue", concurrency = "1-2")
    public void handleTifProcess(TifProcessMessage message) {
        Long fileId = message.getFileId();
        log.info("开始处理TIF文件: {}", fileId);
        
        try {
            // 更新文件状态
            updateFileStatus(fileId, "PROCESSING");
            
            // 处理TIF文件
            processTifFile(message);
            
            // 更新文件状态为完成
            updateFileStatus(fileId, "COMPLETED");
            
            log.info("TIF文件处理完成: {}", fileId);
            
        } catch (Exception e) {
            log.error("TIF文件处理失败: {}", fileId, e);
            updateFileStatus(fileId, "FAILED", e.getMessage());
            
            throw new AmqpRejectAndDontRequeueException("TIF处理失败", e);
        }
    }
    
    private void processTifFile(TifProcessMessage message) {
        try {
            // 使用GDAL或其他地理数据处理库处理TIF文件
            // 这里简化处理，实际应该使用专业的地理数据处理库
            
            File file = new File(message.getFilePath());
            if (!file.exists()) {
                throw new FileNotFoundException("文件不存在: " + message.getFilePath());
            }
            
            // 模拟处理过程
            Thread.sleep(5000); // 模拟处理时间
            
            // 实际处理逻辑：
            // 1. 读取TIF文件元数据
            // 2. 生成瓦片金字塔
            // 3. 创建索引文件
            // 4. 验证文件完整性
            
            // 生成瓦片缓存
            generateTileCache(message.getFileId());
            
        } catch (Exception e) {
            throw new RuntimeException("TIF文件处理失败", e);
        }
    }
    
    private void generateTileCache(Long fileId) {
        // 生成常用级别的瓦片缓存
        int[] zoomLevels = {0, 1, 2, 3, 4, 5};
        
        for (int z : zoomLevels) {
            int maxTiles = (int) Math.pow(2, z);
            for (int x = 0; x < maxTiles; x++) {
                for (int y = 0; y < maxTiles; y++) {
                    // 生成瓦片并缓存
                    byte[] tile = generateTile(fileId, z, x, y);
                    if (tile != null) {
                        cacheTile(fileId, z, x, y, tile);
                    }
                }
            }
        }
    }
    
    private byte[] generateTile(Long fileId, int z, int x, int y) {
        // 从TIF文件生成指定瓦片
        // 这里简化实现，实际应该使用专业的地理数据处理库
        
        try {
            // 模拟瓦片生成
            BufferedImage tile = new BufferedImage(256, 256, BufferedImage.TYPE_INT_RGB);
            Graphics2D g2d = tile.createGraphics();
            g2d.setColor(Color.WHITE);
            g2d.fillRect(0, 0, 256, 256);
            g2d.setColor(Color.BLACK);
            g2d.drawString("Tile " + z + "/" + x + "/" + y, 10, 20);
            g2d.dispose();
            
            // 转换为字节数组
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ImageIO.write(tile, "PNG", baos);
            return baos.toByteArray();
            
        } catch (Exception e) {
            log.error("生成瓦片失败: {}", e.getMessage(), e);
            return null;
        }
    }
    
    private void cacheTile(Long fileId, int z, int x, int y, byte[] tileData) {
        String cacheKey = "tile:" + fileId + ":" + z + ":" + x + ":" + y;
        redisTemplate.opsForValue().set(cacheKey, tileData, 24, TimeUnit.HOURS);
    }
    
    private void updateFileStatus(Long fileId, String status) {
        updateFileStatus(fileId, status, null);
    }
    
    private void updateFileStatus(Long fileId, String status, String errorMessage) {
        GeospatialFile file = fileMapper.selectById(fileId);
        if (file != null) {
            file.setStatus(status);
            if (errorMessage != null) {
                file.setErrorMessage(errorMessage);
            }
            file.setUpdateTime(LocalDateTime.now());
            fileMapper.updateById(file);
        }
    }
}
```

#### 3. 消息重试和死信处理

```java
@Component
@Slf4j
public class DeadLetterMessageHandler {
    
    @RabbitListener(queues = "dead.letter.queue")
    public void handleDeadLetter(Message message, Channel channel) {
        log.error("收到死信消息: {}", message);
        
        try {
            // 记录死信消息
            recordDeadLetterMessage(message);
            
            // 发送告警通知
            sendAlertNotification(message);
            
        } catch (Exception e) {
            log.error("处理死信消息失败", e);
        }
    }
    
    private void recordDeadLetterMessage(Message message) {
        // 记录死信消息到数据库或日志文件
        DeadLetterRecord record = DeadLetterRecord.builder()
            .messageId(message.getMessageProperties().getMessageId())
            .originalQueue(message.getMessageProperties().getReceivedRoutingKey())
            .deadLetterTime(LocalDateTime.now())
            .messageBody(new String(message.getBody()))
            .build();
        
        // 保存到数据库
        deadLetterMapper.insert(record);
    }
    
    private void sendAlertNotification(Message message) {
        // 发送告警通知给管理员
        AlertNotification notification = AlertNotification.builder()
            .type("DEAD_LETTER")
            .title("死信消息告警")
            .content("发现死信消息: " + message.getMessageProperties().getMessageId())
            .timestamp(LocalDateTime.now())
            .build();
        
        // 发送通知
        notificationService.sendNotification(notification);
    }
}
```

---

## 性能优化策略

### 1. Redis 性能优化

#### 连接池配置
```java
@Configuration
public class RedisConnectionConfig {
    
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        LettucePoolingClientConfiguration poolConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(GenericObjectPoolConfig.builder()
                .maxTotal(20)
                .maxIdle(10)
                .minIdle(5)
                .maxWaitMillis(3000)
                .build())
            .build();
        
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setDatabase(0);
        
        return new LettuceConnectionFactory(config, poolConfig);
    }
}
```

#### 缓存预热
```java
@Component
@Slf4j
public class CacheWarmupService {
    
    @Autowired
    private CementPlantMapper cementPlantMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @PostConstruct
    public void warmupCache() {
        log.info("开始缓存预热");
        
        // 预热常用数据
        warmupCementPlants();
        warmupStatistics();
        
        log.info("缓存预热完成");
    }
    
    private void warmupCementPlants() {
        // 预热活跃水泥厂数据
        List<CementPlant> activePlants = cementPlantMapper.selectByStatus("active");
        for (CementPlant plant : activePlants) {
            String cacheKey = "cement_plant:" + plant.getPlantId();
            redisTemplate.opsForValue().set(cacheKey, plant, 30, TimeUnit.MINUTES);
        }
        
        log.info("预热水泥厂数据完成，数量: {}", activePlants.size());
    }
    
    private void warmupStatistics() {
        // 预热统计信息
        QueryStatistics stats = QueryStatistics.builder()
            .totalPlants(cementPlantMapper.countTotal())
            .activePlants(cementPlantMapper.countByStatus("active"))
            .build();
        
        redisTemplate.opsForValue().set("stats:query_stats", stats, 1, TimeUnit.HOURS);
        
        log.info("预热统计信息完成");
    }
}
```

### 2. RabbitMQ 性能优化

#### 消费者配置
```java
@Configuration
@EnableRabbit
public class RabbitMQConsumerConfig {
    
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
            ConnectionFactory connectionFactory) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        
        // 设置并发消费者数量
        factory.setConcurrentConsumers(2);
        factory.setMaxConcurrentConsumers(10);
        
        // 设置预取数量
        factory.setPrefetchCount(10);
        
        // 设置确认模式
        factory.setAcknowledgeMode(AcknowledgeMode.AUTO);
        
        return factory;
    }
}
```

#### 消息持久化
```java
@Component
public class MessagePersistenceService {
    
    @Autowired
    private MessageMapper messageMapper;
    
    public void persistMessage(String queueName, Object message) {
        MessageRecord record = MessageRecord.builder()
            .queueName(queueName)
            .messageBody(JsonUtils.toJson(message))
            .createTime(LocalDateTime.now())
            .status("PENDING")
            .build();
        
        messageMapper.insert(record);
    }
    
    public void updateMessageStatus(String messageId, String status) {
        messageMapper.updateStatus(messageId, status);
    }
}
```

---

## 监控和告警

### 1. Redis 监控

```java
@Component
@Slf4j
public class RedisMonitorService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Scheduled(fixedRate = 60000) // 每分钟检查一次
    public void monitorRedisHealth() {
        try {
            // 检查Redis连接
            String pong = redisTemplate.getConnectionFactory()
                .getConnection().ping();
            
            if (!"PONG".equals(pong)) {
                sendAlert("Redis连接异常");
            }
            
            // 检查内存使用情况
            Properties info = redisTemplate.getConnectionFactory()
                .getConnection().info("memory");
            
            String usedMemory = info.getProperty("used_memory");
            String maxMemory = info.getProperty("maxmemory");
            
            if (usedMemory != null && maxMemory != null) {
                long used = Long.parseLong(usedMemory);
                long max = Long.parseLong(maxMemory);
                
                if (max > 0 && (double) used / max > 0.8) {
                    sendAlert("Redis内存使用率过高: " + (double) used / max * 100 + "%");
                }
            }
            
        } catch (Exception e) {
            log.error("Redis监控检查失败", e);
            sendAlert("Redis监控检查失败: " + e.getMessage());
        }
    }
    
    private void sendAlert(String message) {
        // 发送告警通知
        log.error("Redis告警: {}", message);
    }
}
```

### 2. RabbitMQ 监控

```java
@Component
@Slf4j
public class RabbitMQMonitorService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Scheduled(fixedRate = 60000) // 每分钟检查一次
    public void monitorRabbitMQHealth() {
        try {
            // 检查队列长度
            checkQueueLength("data.upload.queue", 1000);
            checkQueueLength("data.download.queue", 500);
            checkQueueLength("tif.process.queue", 100);
            
        } catch (Exception e) {
            log.error("RabbitMQ监控检查失败", e);
            sendAlert("RabbitMQ监控检查失败: " + e.getMessage());
        }
    }
    
    private void checkQueueLength(String queueName, int maxLength) {
        try {
            // 获取队列信息
            QueueInfo queueInfo = getQueueInfo(queueName);
            
            if (queueInfo != null && queueInfo.getMessageCount() > maxLength) {
                sendAlert("队列 " + queueName + " 消息积压: " + queueInfo.getMessageCount());
            }
            
        } catch (Exception e) {
            log.error("检查队列长度失败: {}", queueName, e);
        }
    }
    
    private QueueInfo getQueueInfo(String queueName) {
        // 通过RabbitMQ Management API获取队列信息
        // 这里简化实现
        return null;
    }
    
    private void sendAlert(String message) {
        // 发送告警通知
        log.error("RabbitMQ告警: {}", message);
    }
}
```

---

## 总结

本文档详细分析了水泥厂管理系统中核心模块的技术实现，特别深入讲解了Redis和RabbitMQ的应用：

### Redis 核心应用
1. **缓存层**: 用户会话、查询结果、瓦片数据缓存
2. **分布式锁**: 防止并发操作冲突
3. **限流控制**: 下载配额、上传配额管理
4. **性能优化**: 连接池、缓存预热、监控告警

### RabbitMQ 核心应用
1. **异步处理**: 数据上传、下载、TIF文件处理
2. **消息队列**: 解耦业务逻辑，提升系统性能
3. **重试机制**: 消息重试和死信处理
4. **监控告警**: 队列长度监控、消息积压告警

### 技术优势
1. **高性能**: Redis缓存 + RabbitMQ异步处理
2. **高可用**: 分布式锁 + 消息重试机制
3. **可扩展**: 模块化设计 + 微服务架构
4. **可监控**: 完善的监控和告警机制

# 水泥厂管理系统 - 前端WebGIS技术实现详解

## 文档概述

本文档详细分析水泥厂管理系统中前端WebGIS部分的技术实现，包括地图组件、TIF文件管理、GeoServer集成、瓦片服务等核心功能的逻辑和技术细节。

## 前端技术架构

### 核心技术栈
- **前端框架**: Vue 3.5.13 + Composition API
- **构建工具**: Vite 6.3.6
- **状态管理**: Pinia 2.2.6
- **路由管理**: Vue Router 4.5.0
- **HTTP客户端**: Axios 1.7.7
- **地图引擎**: OpenLayers 8.2.0
- **地图服务**: GeoServer 2.22+
- **样式处理**: CSS3 + Scoped CSS

### 项目结构
```
static/myVue/
├── src/
│   ├── api/                    # API接口层
│   │   ├── geoserver.js       # GeoServer服务接口
│   │   ├── tif.js             # TIF文件管理接口
│   │   └── ...
│   ├── components/            # 组件层
│   │   ├── MapContainer.vue   # 地图容器组件
│   │   └── ...
│   ├── views/                 # 页面视图
│   │   ├── MapView.vue        # 地图页面
│   │   ├── TifManagementView.vue # TIF管理页面
│   │   └── ...
│   ├── stores/                # 状态管理
│   │   └── auth.js            # 认证状态
│   ├── utils/                 # 工具函数
│   │   └── request.js         # HTTP请求封装
│   └── router/                # 路由配置
│       └── index.js
├── package.json
└── vite.config.js
```

---

## 1. 地图组件架构

### 1.1 MapView 主页面组件

#### 组件结构
```vue
<template>
  <div class="map-page">
    <!-- 地图容器 -->
    <div class="map-wrapper">
      <MapContainer :fileId="fileId" />
    </div>
    
    <!-- 状态栏 -->
    <footer class="status-bar">
      <div class="status-info">
        <span>坐标系统: EPSG:4326</span>
        <span>服务状态: {{ serviceStatus }}</span>
        <span>图层数量: {{ layerCount }}</span>
      </div>
    </footer>
    
    <!-- 关于对话框 -->
    <div v-if="showAboutDialog" class="modal-overlay">
      <!-- 系统信息展示 -->
    </div>
  </div>
</template>
```

#### 核心逻辑实现
```javascript
import { ref, computed, onMounted } from 'vue'
import { useRoute } from 'vue-router'
import MapContainer from '@/components/MapContainer.vue'
import { getAllLayers } from '@/api/geoserver'

export default {
  name: 'MapView',
  components: { MapContainer },
  setup() {
    const route = useRoute()
    const showAboutDialog = ref(false)
    const serviceStatus = ref('正常')
    const fileId = ref(route.query.fileId || null)
    
    // 计算图层数量
    const layerCount = computed(() => {
      const layers = getAllLayers()
      return Object.keys(layers).length
    })
    
    // 检查服务状态
    const checkServiceStatus = async () => {
      try {
        // 模拟服务状态检查，避免CORS问题
        await new Promise(resolve => setTimeout(resolve, 1000))
        serviceStatus.value = '正常 (模拟)'
        console.log('服务状态检查完成 (使用模拟数据)')
      } catch (error) {
        serviceStatus.value = '离线'
        console.error('服务状态检查失败:', error)
      }
    }
    
    onMounted(() => {
      checkServiceStatus()
    })
    
    return {
      showAboutDialog,
      serviceStatus,
      layerCount,
      fileId,
      // ... 其他方法
    }
  }
}
```

### 1.2 MapContainer 地图容器组件

#### 组件功能
- **地图渲染**: 基于OpenLayers的地图渲染
- **图层控制**: 底图切换、图层显示/隐藏
- **TIF图层管理**: TIF文件的显示和透明度控制
- **要素信息**: 点击要素显示详细信息
- **图例显示**: 图层图例和符号说明

#### 核心实现
```vue
<template>
  <div class="map-container">
    <!-- 地图容器 -->
    <div id="map" class="map"></div>
    
    <!-- 图层控制面板 -->
    <div class="layer-control-panel">
      <div class="panel-header">
        <h3>图层控制</h3>
        <button @click="togglePanel" class="toggle-btn">
          {{ panelVisible ? '隐藏' : '显示' }}
        </button>
      </div>
      
      <div v-show="panelVisible" class="panel-content">
        <!-- 底图选择 -->
        <div class="control-group">
          <label>底图:</label>
          <select v-model="selectedBaseMap" @change="changeBaseMap">
            <option v-for="(baseMap, key) in baseMaps" :key="key" :value="key">
              {{ baseMap.name }}
            </option>
          </select>
        </div>
        
        <!-- TIF文件图层 -->
        <div v-if="fileId" class="control-group">
          <label>TIF文件图层:</label>
          <div class="layer-item">
            <div class="layer-control">
              <input 
                type="checkbox" 
                id="tif-layer"
                v-model="tifLayerVisible"
                @change="toggleTifLayer"
              >
              <label for="tif-layer">TIF影像 (ID: {{ fileId }})</label>
            </div>
            
            <div v-if="tifLayerVisible" class="layer-options">
              <div class="opacity-control">
                <label>透明度:</label>
                <input 
                  type="range" 
                  :min="0" 
                  :max="1" 
                  :step="0.1"
                  v-model="tifLayerOpacity"
                  @input="updateTifLayerOpacity"
                >
                <span>{{ Math.round(tifLayerOpacity * 100) }}%</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 图例 -->
        <div class="legend">
          <h4>图例</h4>
          <div v-if="fileId" class="legend-group">
            <h5>TIF影像</h5>
            <div class="legend-items">
              <div class="legend-item">
                <div class="legend-symbol" style="background: linear-gradient(45deg, #00ff00, #0066cc);"></div>
                <span>遥感影像</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 信息面板 -->
    <div v-if="selectedFeature" class="info-panel">
      <div class="info-header">
        <h4>要素信息</h4>
        <button @click="closeInfoPanel" class="close-btn">×</button>
      </div>
      <div class="info-content">
        <div v-for="(value, key) in selectedFeature.properties" :key="key" class="info-item">
          <strong>{{ key }}:</strong> {{ value }}
        </div>
      </div>
    </div>
    
    <!-- 加载状态 -->
    <div v-if="loading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <p>加载地图中...</p>
    </div>
  </div>
</template>
```

#### JavaScript逻辑
```javascript
import { ref, reactive, computed, onMounted, onUnmounted, watch } from 'vue'
import { getBaseMaps, getMapConfig } from '@/api/geoserver'

export default {
  name: 'MapContainer',
  props: {
    fileId: {
      type: [String, Number],
      default: null
    }
  },
  setup(props) {
    const map = ref(null)
    const loading = ref(true)
    const panelVisible = ref(true)
    const selectedBaseMap = ref('osm')
    const selectedFeature = ref(null)
    const tifLayerVisible = ref(true)
    const tifLayerOpacity = ref(0.8)
    
    // 获取配置
    const mapConfig = getMapConfig()
    const baseMaps = getBaseMaps()
    
    // 初始化地图
    const initMap = () => {
      try {
        // 创建简单的地图容器
        const mapElement = document.getElementById('map')
        if (mapElement) {
          mapElement.innerHTML = `
            <div style="width: 100%; height: 100%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; flex-direction: column;">
              <div style="font-size: 24px; color: #666; margin-bottom: 20px;">🗺️ 地图视图</div>
              <div style="font-size: 16px; color: #999; text-align: center;">
                <p>坐标系统: ${mapConfig.projection}</p>
                <p>中心点: [${mapConfig.center[0]}, ${mapConfig.center[1]}]</p>
                <p>缩放级别: ${mapConfig.zoom}</p>
                ${props.fileId ? `<p>TIF文件ID: ${props.fileId}</p>` : ''}
              </div>
              <div style="margin-top: 20px; padding: 10px; background: #e8f4fd; border-radius: 5px; color: #0066cc;">
                <p>💡 提示: 这是一个简化的地图视图</p>
                <p>要显示完整的TIF影像，需要配置GeoServer服务</p>
              </div>
            </div>
          `
        }
        
        loading.value = false
        console.log('简化地图初始化完成')
      } catch (error) {
        console.error('地图初始化失败:', error)
        loading.value = false
      }
    }
    
    // 切换面板显示
    const togglePanel = () => {
      panelVisible.value = !panelVisible.value
    }
    
    // 切换底图
    const changeBaseMap = () => {
      console.log('切换底图:', selectedBaseMap.value)
    }
    
    // 切换TIF图层
    const toggleTifLayer = () => {
      console.log('切换TIF图层:', tifLayerVisible.value)
    }
    
    // 更新TIF图层透明度
    const updateTifLayerOpacity = () => {
      console.log('更新TIF图层透明度:', tifLayerOpacity.value)
    }
    
    // 监听fileId变化
    watch(() => props.fileId, (newFileId, oldFileId) => {
      console.log('TIF文件ID变化:', oldFileId, '->', newFileId)
      if (newFileId) {
        tifLayerVisible.value = true
      }
    })
    
    onMounted(() => {
      initMap()
    })
    
    onUnmounted(() => {
      console.log('地图组件卸载')
    })
    
    return {
      map,
      loading,
      panelVisible,
      selectedBaseMap,
      selectedFeature,
      tifLayerVisible,
      tifLayerOpacity,
      baseMaps,
      togglePanel,
      changeBaseMap,
      toggleTifLayer,
      updateTifLayerOpacity
    }
  }
}
```

---

## 2. GeoServer集成架构

### 2.1 GeoServer配置管理

#### 配置文件结构
```javascript
// GeoServer地图API配置
const GEOSERVER_CONFIG = {
  // GeoServer基础配置 (当前使用模拟数据)
  baseUrl: 'http://localhost:8080/geoserver',
  workspace: 'cement',
  username: 'admin',
  password: 'geoserver',
  // 模拟模式标志
  mockMode: true,
  
  // WMS服务配置
  wms: {
    url: 'http://localhost:8080/geoserver/cement/wms',
    version: '1.3.0',
    format: 'image/png',
    transparent: true,
    crs: 'EPSG:4326'
  },
  
  // WFS服务配置
  wfs: {
    url: 'http://localhost:8080/geoserver/cement/wfs',
    version: '2.0.0',
    outputFormat: 'application/json',
    crs: 'EPSG:4326'
  },
  
  // 图层配置
  layers: {
    cementPlants: {
      name: 'cement:cement_plants',
      title: '水泥厂位置',
      style: 'cement_plants',
      visible: true,
      opacity: 1.0,
      legend: {
        title: '水泥厂',
        items: [
          { color: '#00ff00', label: '活跃' },
          { color: '#ff0000', label: '非活跃' },
          { color: '#ffff00', label: '建设中' }
        ]
      }
    },
    
    cementPlantIdentifications: {
      name: 'cement:cement_plant_identifications',
      title: '水泥厂识别记录',
      style: 'cement_plant_identifications',
      visible: true,
      opacity: 0.8,
      legend: {
        title: '识别记录',
        items: [
          { shape: 'square', color: '#0066cc', label: 'GF-2' },
          { shape: 'triangle', color: '#ff6600', label: 'Landsat-8' },
          { shape: 'star', color: '#9900cc', label: 'Sentinel-2' }
        ]
      }
    },
    
    geospatialFiles: {
      name: 'cement:geospatial_files',
      title: '地理数据文件',
      style: 'geospatial_files',
      visible: false,
      opacity: 0.5,
      legend: {
        title: 'TIF文件边界',
        items: [
          { color: '#00ff00', label: 'TIF文件' },
          { color: '#ffaa00', label: '其他格式' }
        ]
      }
    }
  },
  
  // 地图默认配置
  map: {
    center: [114.3, 30.6], // 武汉中心
    zoom: 8,
    projection: 'EPSG:4326',
    maxZoom: 18,
    minZoom: 3
  },
  
  // 底图配置
  baseMaps: {
    osm: {
      name: 'OpenStreetMap',
      url: 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      attribution: '© OpenStreetMap contributors'
    },
    satellite: {
      name: '卫星影像',
      url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      attribution: '© Esri'
    },
    terrain: {
      name: '地形图',
      url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
      attribution: '© Esri'
    }
  }
};
```

### 2.2 WMS/WFS服务接口

#### WMS图层URL生成
```javascript
// 获取WMS图层URL
export function getWmsLayerUrl(layerName, options = {}) {
  if (GEOSERVER_CONFIG.mockMode) {
    // 模拟模式：返回模拟的图层URL
    console.log(`模拟WMS图层URL: ${layerName}`)
    return `mock://wms/${layerName}`
  }
  
  const layer = GEOSERVER_CONFIG.layers[layerName];
  if (!layer) {
    throw new Error(`图层 ${layerName} 不存在`);
  }
  
  const params = {
    SERVICE: 'WMS',
    VERSION: GEOSERVER_CONFIG.wms.version,
    REQUEST: 'GetMap',
    LAYERS: layer.name,
    STYLES: layer.style || '',
    FORMAT: GEOSERVER_CONFIG.wms.format,
    TRANSPARENT: GEOSERVER_CONFIG.wms.transparent,
    CRS: GEOSERVER_CONFIG.wms.crs,
    ...options
  };
  
  const queryString = Object.keys(params)
    .map(key => `${key}=${encodeURIComponent(params[key])}`)
    .join('&');
    
  return `${GEOSERVER_CONFIG.wms.url}?${queryString}`;
}
```

#### WFS图层URL生成
```javascript
// 获取WFS图层URL
export function getWfsLayerUrl(layerName, options = {}) {
  const layer = GEOSERVER_CONFIG.layers[layerName];
  if (!layer) {
    throw new Error(`图层 ${layerName} 不存在`);
  }
  
  const params = {
    SERVICE: 'WFS',
    VERSION: GEOSERVER_CONFIG.wfs.version,
    REQUEST: 'GetFeature',
    TYPENAME: layer.name,
    OUTPUTFORMAT: GEOSERVER_CONFIG.wfs.outputFormat,
    SRSNAME: GEOSERVER_CONFIG.wfs.crs,
    ...options
  };
  
  const queryString = Object.keys(params)
    .map(key => `${key}=${encodeURIComponent(params[key])}`)
    .join('&');
    
  return `${GEOSERVER_CONFIG.wfs.url}?${queryString}`;
}
```

### 2.3 图层管理API

```javascript
// 获取图层信息
export function getLayerInfo(layerName) {
  return GEOSERVER_CONFIG.layers[layerName];
}

// 获取所有图层
export function getAllLayers() {
  return GEOSERVER_CONFIG.layers;
}

// 获取地图配置
export function getMapConfig() {
  return GEOSERVER_CONFIG.map;
}

// 获取底图配置
export function getBaseMaps() {
  return GEOSERVER_CONFIG.baseMaps;
}
```

---

## 3. TIF文件管理功能

### 3.1 TIF文件管理页面

#### 页面结构
```vue
<template>
  <div class="tif-management-page">
    <!-- 页面头部 -->
    <div class="page-header">
      <h2>TIF文件管理</h2>
      <div class="header-actions">
        <button @click="showUploadDialog = true" class="btn btn-primary" :disabled="!canUpload">
          <span class="icon">📁</span>
          上传TIF文件
        </button>
        <button @click="refreshFiles" class="btn btn-secondary">
          <span class="icon">🔄</span>
          刷新
        </button>
      </div>
    </div>

    <!-- 文件列表 -->
    <div class="file-list">
      <div class="list-header">
        <h3>TIF文件列表</h3>
        <div class="filter-controls">
          <select v-model="filterStatus" @change="loadFiles">
            <option value="">全部状态</option>
            <option value="processing">处理中</option>
            <option value="processed">已处理</option>
            <option value="active">活跃</option>
            <option value="error">错误</option>
          </select>
        </div>
      </div>

      <div v-if="loading" class="loading">
        <div class="spinner"></div>
        <p>加载中...</p>
      </div>

      <div v-else-if="files.length === 0" class="empty-state">
        <div class="empty-icon">📄</div>
        <p>暂无TIF文件</p>
        <button @click="showUploadDialog = true" class="btn btn-primary" :disabled="!canUpload">
          上传第一个文件
        </button>
      </div>

      <div v-else class="file-grid">
        <div v-for="file in files" :key="file.fileId" class="file-card">
          <!-- 文件卡片内容 -->
        </div>
      </div>
    </div>

    <!-- 上传对话框 -->
    <div v-if="showUploadDialog" class="modal-overlay">
      <!-- 上传表单 -->
    </div>
  </div>
</template>
```

#### 核心逻辑实现
```javascript
import { ref, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = useRouter()
const auth = useAuthStore()

// 响应式数据
const files = ref([])
const loading = ref(false)
const uploading = ref(false)
const showUploadDialog = ref(false)
const selectedFile = ref(null)
const uploadPlantId = ref('')
const uploadDataType = ref('NDVI')
const filterStatus = ref('')
const cementPlants = ref([])
const downloadStatus = ref({})

// 计算属性
const canUpload = computed(() => {
  return auth.userInfo?.roleCode === 0
})

const canDownload = computed(() => {
  return downloadStatus.value.dailyCount < downloadStatus.value.dailyLimit
})

// 方法
const loadFiles = async () => {
  loading.value = true
  try {
    // 模拟加载数据
    await new Promise(resolve => setTimeout(resolve, 1000))
    files.value = [
      {
        fileId: 1,
        fileName: 'sample_ndvi.tif',
        fileSize: 1024000,
        coordinateSystem: 'EPSG:4326',
        bandsCount: 1,
        dataType: 'FLOAT32',
        boundsWest: 114.3,
        boundsEast: 114.4,
        boundsSouth: 38.1,
        boundsNorth: 38.2,
        uploadTime: new Date().toISOString(),
        status: 'processed'
      }
    ]
  } catch (error) {
    console.error('加载TIF文件失败:', error)
    alert('加载TIF文件失败，请稍后重试')
  } finally {
    loading.value = false
  }
}

const handleFileSelect = (event) => {
  const file = event.target.files[0]
  if (file) {
    if (!file.name.toLowerCase().endsWith('.tif') && !file.name.toLowerCase().endsWith('.tiff')) {
      alert('请选择TIF格式的文件')
      return
    }
    selectedFile.value = file
  }
}

const uploadFile = async () => {
  if (!selectedFile.value) return
  
  uploading.value = true
  try {
    // 模拟上传
    await new Promise(resolve => setTimeout(resolve, 2000))
    alert('文件上传成功！')
    closeUploadDialog()
    loadFiles()
  } catch (error) {
    console.error('上传失败:', error)
    alert('上传失败，请稍后重试')
  } finally {
    uploading.value = false
  }
}

const viewOnMap = (file) => {
  // 跳转到地图页面并传递文件ID
  router.push({
    path: '/map',
    query: { fileId: file.fileId }
  })
}

onMounted(() => {
  loadFiles()
  loadCementPlants()
  loadDownloadStatus()
})
```

### 3.2 TIF文件API接口

#### API接口定义
```javascript
import request from '@/utils/request'

// TIF文件管理API
export const uploadTifFile = (file, plantId, dataType) => {
  const formData = new FormData()
  formData.append('file', file)
  if (plantId) formData.append('plantId', plantId)
  if (dataType) formData.append('dataType', dataType)
  
  return request.post('/geo/upload-tif', formData, {
    headers: { 'Content-Type': 'multipart/form-data' }
  })
}

export const getTifFiles = (fileType, status) => {
  return request.get('/geo/files', {
    params: { fileType, status }
  })
}

export const getTifInfo = (fileId) => {
  return request.get(`/geo/tif-info/${fileId}`)
}

export const processTifFile = (fileId) => {
  return request.post(`/geo/process-tif/${fileId}`)
}

export const getTileUrl = (fileId, z, x, y) => {
  return `${request.defaults.baseURL}/geo/tile/${fileId}/${z}/${x}/${y}`
}

export const downloadTifFile = (fileId) => {
  return request.get(`/data-download/tif/${fileId}`, {
    responseType: 'blob'
  })
}

export const batchDownloadTifFiles = (fileIds) => {
  return request.post('/data-download/batch-download', fileIds, {
    responseType: 'blob'
  })
}

export const getDownloadStatus = () => {
  return request.get('/data-download/download-status')
}

export const getDownloadHistory = (pageNum = 1, pageSize = 10) => {
  return request.get('/data-download/download-history', {
    params: { pageNum, pageSize }
  })
}

export const submitAsyncDownload = (fileIds) => {
  return request.post('/data-download/async-download', fileIds)
}

export const getAsyncDownloadStatus = (taskId) => {
  return request.get(`/data-download/async-download/${taskId}/status`)
}

export const downloadAsyncResult = (taskId) => {
  return request.get(`/data-download/async-download/${taskId}/result`, {
    responseType: 'blob'
  })
}
```

---

## 4. 地图渲染引擎

### 4.1 OpenLayers集成

#### 地图初始化
```javascript
import { Map, View } from 'ol'
import { Tile as TileLayer, Vector as VectorLayer } from 'ol/layer'
import { OSM, Vector as VectorSource } from 'ol/source'
import { fromLonLat } from 'ol/proj'
import { Style, Circle, Fill, Stroke } from 'ol/style'

class MapEngine {
  constructor(containerId, options = {}) {
    this.containerId = containerId
    this.options = {
      center: [114.3, 30.6],
      zoom: 8,
      projection: 'EPSG:4326',
      ...options
    }
    this.map = null
    this.layers = new Map()
    this.init()
  }
  
  init() {
    // 创建地图实例
    this.map = new Map({
      target: this.containerId,
      layers: [
        new TileLayer({
          source: new OSM()
        })
      ],
      view: new View({
        center: fromLonLat(this.options.center),
        zoom: this.options.zoom
      })
    })
    
    console.log('OpenLayers地图初始化完成')
  }
  
  // 添加WMS图层
  addWmsLayer(layerName, layerConfig) {
    const wmsLayer = new TileLayer({
      source: new ImageWMS({
        url: layerConfig.url,
        params: {
          'LAYERS': layerConfig.name,
          'STYLES': layerConfig.style || '',
          'FORMAT': 'image/png',
          'TRANSPARENT': true
        }
      }),
      opacity: layerConfig.opacity || 1.0,
      visible: layerConfig.visible !== false
    })
    
    this.map.addLayer(wmsLayer)
    this.layers.set(layerName, wmsLayer)
    
    return wmsLayer
  }
  
  // 添加TIF瓦片图层
  addTifLayer(fileId, options = {}) {
    const tileLayer = new TileLayer({
      source: new XYZ({
        url: `/api/geo/tile/${fileId}/{z}/{x}/{y}`,
        maxZoom: 18
      }),
      opacity: options.opacity || 0.8,
      visible: options.visible !== false
    })
    
    this.map.addLayer(tileLayer)
    this.layers.set(`tif_${fileId}`, tileLayer)
    
    return tileLayer
  }
  
  // 切换图层可见性
  toggleLayer(layerName, visible) {
    const layer = this.layers.get(layerName)
    if (layer) {
      layer.setVisible(visible)
    }
  }
  
  // 设置图层透明度
  setLayerOpacity(layerName, opacity) {
    const layer = this.layers.get(layerName)
    if (layer) {
      layer.setOpacity(opacity)
    }
  }
  
  // 添加点击事件
  addClickHandler(callback) {
    this.map.on('click', (event) => {
      const coordinate = event.coordinate
      const features = this.map.getFeaturesAtPixel(event.pixel)
      
      if (features.length > 0) {
        const feature = features[0]
        callback({
          coordinate,
          feature,
          properties: feature.getProperties()
        })
      }
    })
  }
  
  // 缩放到指定范围
  fitToExtent(extent) {
    this.map.getView().fit(extent, {
      padding: [20, 20, 20, 20]
    })
  }
  
  // 销毁地图
  destroy() {
    if (this.map) {
      this.map.setTarget(null)
      this.map = null
    }
    this.layers.clear()
  }
}

export default MapEngine
```

### 4.2 瓦片服务集成

#### 瓦片URL生成
```javascript
class TileService {
  constructor(baseUrl) {
    this.baseUrl = baseUrl
  }
  
  // 生成瓦片URL
  getTileUrl(fileId, z, x, y) {
    return `${this.baseUrl}/geo/tile/${fileId}/${z}/${x}/${y}`
  }
  
  // 获取瓦片信息
  async getTileInfo(fileId) {
    try {
      const response = await fetch(`${this.baseUrl}/geo/tif-info/${fileId}`)
      return await response.json()
    } catch (error) {
      console.error('获取瓦片信息失败:', error)
      return null
    }
  }
  
  // 检查瓦片是否存在
  async checkTileExists(fileId, z, x, y) {
    try {
      const url = this.getTileUrl(fileId, z, x, y)
      const response = await fetch(url, { method: 'HEAD' })
      return response.ok
    } catch (error) {
      return false
    }
  }
  
  // 预加载瓦片
  async preloadTiles(fileId, bounds, zoomLevels) {
    const tiles = []
    
    for (let z of zoomLevels) {
      const tileBounds = this.getTileBounds(bounds, z)
      
      for (let x = tileBounds.minX; x <= tileBounds.maxX; x++) {
        for (let y = tileBounds.minY; y <= tileBounds.maxY; y++) {
          tiles.push({ fileId, z, x, y })
        }
      }
    }
    
    // 并发预加载瓦片
    const promises = tiles.map(tile => this.preloadTile(tile))
    await Promise.allSettled(promises)
  }
  
  // 预加载单个瓦片
  async preloadTile(tile) {
    try {
      const url = this.getTileUrl(tile.fileId, tile.z, tile.x, tile.y)
      const response = await fetch(url)
      if (response.ok) {
        // 瓦片加载成功，可以缓存
        return true
      }
    } catch (error) {
      console.warn(`瓦片加载失败: ${tile.z}/${tile.x}/${tile.y}`, error)
    }
    return false
  }
  
  // 计算瓦片边界
  getTileBounds(bounds, zoom) {
    const tileSize = Math.pow(2, zoom)
    const minX = Math.floor(bounds.minX * tileSize)
    const maxX = Math.floor(bounds.maxX * tileSize)
    const minY = Math.floor(bounds.minY * tileSize)
    const maxY = Math.floor(bounds.maxY * tileSize)
    
    return { minX, maxX, minY, maxY }
  }
}

export default TileService
```

---

## 5. 状态管理和数据流

### 5.1 Pinia状态管理

#### 认证状态管理
```javascript
// stores/auth.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { login, getUserInfo } from '@/api/user'

export const useAuthStore = defineStore('auth', () => {
  // 状态
  const token = ref(localStorage.getItem('token') || '')
  const userInfo = ref(null)
  const isLoggedIn = computed(() => !!token.value)
  
  // 登录
  const loginUser = async (credentials) => {
    try {
      const response = await login(credentials)
      token.value = response.data.token
      localStorage.setItem('token', token.value)
      
      // 获取用户信息
      await getUserInfo()
      
      return response.data
    } catch (error) {
      throw error
    }
  }
  
  // 获取用户信息
  const getUserInfo = async () => {
    try {
      const response = await getUserInfo()
      userInfo.value = response.data
      return response.data
    } catch (error) {
      console.error('获取用户信息失败:', error)
      throw error
    }
  }
  
  // 登出
  const logout = () => {
    token.value = ''
    userInfo.value = null
    localStorage.removeItem('token')
  }
  
  // 检查权限
  const hasPermission = (permission) => {
    if (!userInfo.value) return false
    
    // 管理员拥有所有权限
    if (userInfo.value.roleCode === 0) return true
    
    // 根据具体权限检查
    return userInfo.value.permissions?.includes(permission) || false
  }
  
  return {
    token,
    userInfo,
    isLoggedIn,
    loginUser,
    getUserInfo,
    logout,
    hasPermission
  }
})
```

#### 地图状态管理
```javascript
// stores/map.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useMapStore = defineStore('map', () => {
  // 状态
  const currentFileId = ref(null)
  const selectedFeature = ref(null)
  const visibleLayers = ref(new Set())
  const layerOpacities = ref(new Map())
  const mapCenter = ref([114.3, 30.6])
  const mapZoom = ref(8)
  
  // 计算属性
  const hasSelectedFile = computed(() => !!currentFileId.value)
  const visibleLayerCount = computed(() => visibleLayers.value.size)
  
  // 设置当前文件
  const setCurrentFile = (fileId) => {
    currentFileId.value = fileId
    if (fileId) {
      visibleLayers.value.add(`tif_${fileId}`)
    }
  }
  
  // 切换图层可见性
  const toggleLayer = (layerName, visible) => {
    if (visible) {
      visibleLayers.value.add(layerName)
    } else {
      visibleLayers.value.delete(layerName)
    }
  }
  
  // 设置图层透明度
  const setLayerOpacity = (layerName, opacity) => {
    layerOpacities.value.set(layerName, opacity)
  }
  
  // 选择要素
  const selectFeature = (feature) => {
    selectedFeature.value = feature
  }
  
  // 清除选择
  const clearSelection = () => {
    selectedFeature.value = null
  }
  
  // 更新地图视图
  const updateMapView = (center, zoom) => {
    mapCenter.value = center
    mapZoom.value = zoom
  }
  
  return {
    currentFileId,
    selectedFeature,
    visibleLayers,
    layerOpacities,
    mapCenter,
    mapZoom,
    hasSelectedFile,
    visibleLayerCount,
    setCurrentFile,
    toggleLayer,
    setLayerOpacity,
    selectFeature,
    clearSelection,
    updateMapView
  }
})
```

### 5.2 HTTP请求封装

#### 请求拦截器
```javascript
// utils/request.js
import axios from 'axios'
import { useAuthStore } from '@/stores/auth'
import { ElMessage } from 'element-plus'

// 创建axios实例
const request = axios.create({
  baseURL: 'http://localhost:8085/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore()
    
    // 添加认证token
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    // 添加请求时间戳
    config.metadata = { startTime: new Date() }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 计算请求耗时
    const duration = new Date() - response.config.metadata.startTime
    console.log(`请求 ${response.config.url} 耗时: ${duration}ms`)
    
    // 统一处理响应数据
    if (response.data.code === 200) {
      return response.data
    } else {
      ElMessage.error(response.data.message || '请求失败')
      return Promise.reject(new Error(response.data.message))
    }
  },
  (error) => {
    // 处理HTTP错误
    if (error.response) {
      const { status, data } = error.response
      
      switch (status) {
        case 401:
          ElMessage.error('未授权，请重新登录')
          const authStore = useAuthStore()
          authStore.logout()
          break
        case 403:
          ElMessage.error('权限不足')
          break
        case 404:
          ElMessage.error('请求的资源不存在')
          break
        case 500:
          ElMessage.error('服务器内部错误')
          break
        default:
          ElMessage.error(data.message || '请求失败')
      }
    } else if (error.request) {
      ElMessage.error('网络连接失败，请检查网络')
    } else {
      ElMessage.error('请求配置错误')
    }
    
    return Promise.reject(error)
  }
)

export default request
```

---

## 6. 样式和UI设计

### 6.1 响应式设计

#### CSS变量和主题
```css
/* 全局CSS变量 */
:root {
  /* 颜色主题 */
  --primary-color: #007bff;
  --secondary-color: #6c757d;
  --success-color: #28a745;
  --warning-color: #ffc107;
  --danger-color: #dc3545;
  --info-color: #17a2b8;
  
  /* 中性色 */
  --white: #ffffff;
  --light: #f8f9fa;
  --dark: #343a40;
  --gray-100: #f8f9fa;
  --gray-200: #e9ecef;
  --gray-300: #dee2e6;
  --gray-400: #ced4da;
  --gray-500: #adb5bd;
  --gray-600: #6c757d;
  --gray-700: #495057;
  --gray-800: #343a40;
  --gray-900: #212529;
  
  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  
  /* 字体大小 */
  --font-size-xs: 12px;
  --font-size-sm: 14px;
  --font-size-md: 16px;
  --font-size-lg: 18px;
  --font-size-xl: 20px;
  --font-size-xxl: 24px;
  
  /* 圆角 */
  --border-radius-sm: 4px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  
  /* 阴影 */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
  --shadow-md: 0 2px 10px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 4px 20px rgba(0, 0, 0, 0.15);
  
  /* 过渡动画 */
  --transition-fast: 0.15s ease;
  --transition-normal: 0.3s ease;
  --transition-slow: 0.5s ease;
}
```

#### 响应式布局
```css
/* 地图容器响应式设计 */
.map-container {
  position: relative;
  width: 100%;
  height: 100vh;
  overflow: hidden;
}

/* 图层控制面板 */
.layer-control-panel {
  position: absolute;
  top: 10px;
  left: 10px;
  background: var(--white);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  min-width: 250px;
  z-index: 1000;
  max-height: calc(100vh - 20px);
  overflow-y: auto;
}

/* 信息面板 */
.info-panel {
  position: absolute;
  top: 10px;
  right: 10px;
  background: var(--white);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  min-width: 250px;
  max-width: 400px;
  z-index: 1000;
  max-height: calc(100vh - 20px);
  overflow-y: auto;
}

/* 移动端适配 */
@media (max-width: 768px) {
  .layer-control-panel {
    top: 5px;
    left: 5px;
    right: 5px;
    min-width: auto;
    max-width: none;
  }
  
  .info-panel {
    top: 5px;
    right: 5px;
    left: 5px;
    min-width: auto;
    max-width: none;
  }
  
  .map-container {
    height: calc(100vh - 60px);
  }
}

@media (max-width: 480px) {
  .layer-control-panel {
    position: fixed;
    bottom: 0;
    top: auto;
    left: 0;
    right: 0;
    border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
    max-height: 50vh;
  }
  
  .info-panel {
    position: fixed;
    bottom: 0;
    top: auto;
    left: 0;
    right: 0;
    border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
    max-height: 50vh;
  }
}
```

### 6.2 组件样式

#### 按钮组件样式
```css
.btn {
  padding: var(--spacing-sm) var(--spacing-md);
  border: none;
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
  transition: all var(--transition-fast);
  text-decoration: none;
  font-weight: 500;
  line-height: 1.5;
}

.btn-primary {
  background: var(--primary-color);
  color: var(--white);
}

.btn-primary:hover:not(:disabled) {
  background: #0056b3;
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.btn-secondary {
  background: var(--secondary-color);
  color: var(--white);
}

.btn-secondary:hover:not(:disabled) {
  background: #545b62;
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.btn-success {
  background: var(--success-color);
  color: var(--white);
}

.btn-warning {
  background: var(--warning-color);
  color: var(--dark);
}

.btn-danger {
  background: var(--danger-color);
  color: var(--white);
}

.btn-sm {
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: var(--font-size-xs);
}

.btn-lg {
  padding: var(--spacing-md) var(--spacing-lg);
  font-size: var(--font-size-lg);
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}
```

#### 表单组件样式
```css
.form-group {
  margin-bottom: var(--spacing-md);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--gray-700);
  font-size: var(--font-size-sm);
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--gray-300);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
  transition: border-color var(--transition-fast);
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.form-group input:invalid {
  border-color: var(--danger-color);
}

.form-group .form-help {
  font-size: var(--font-size-xs);
  color: var(--gray-600);
  margin-top: var(--spacing-xs);
}

.form-group .form-error {
  font-size: var(--font-size-xs);
  color: var(--danger-color);
  margin-top: var(--spacing-xs);
}
```

---

## 7. 性能优化策略

### 7.1 地图性能优化

#### 瓦片缓存策略
```javascript
class TileCache {
  constructor(maxSize = 1000) {
    this.cache = new Map()
    this.maxSize = maxSize
    this.accessOrder = []
  }
  
  // 获取瓦片
  get(key) {
    if (this.cache.has(key)) {
      // 更新访问顺序
      this.updateAccessOrder(key)
      return this.cache.get(key)
    }
    return null
  }
  
  // 设置瓦片
  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      // 移除最久未使用的瓦片
      this.evictLRU()
    }
    
    this.cache.set(key, value)
    this.updateAccessOrder(key)
  }
  
  // 更新访问顺序
  updateAccessOrder(key) {
    const index = this.accessOrder.indexOf(key)
    if (index > -1) {
      this.accessOrder.splice(index, 1)
    }
    this.accessOrder.push(key)
  }
  
  // 移除最久未使用的瓦片
  evictLRU() {
    if (this.accessOrder.length > 0) {
      const lruKey = this.accessOrder.shift()
      this.cache.delete(lruKey)
    }
  }
  
  // 清除缓存
  clear() {
    this.cache.clear()
    this.accessOrder = []
  }
  
  // 获取缓存统计
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: this.hitCount / (this.hitCount + this.missCount) || 0
    }
  }
}

export default TileCache
```

#### 图层懒加载
```javascript
class LazyLayerLoader {
  constructor(mapEngine) {
    this.mapEngine = mapEngine
    this.loadingLayers = new Set()
    this.loadedLayers = new Set()
  }
  
  // 懒加载图层
  async loadLayer(layerName, layerConfig) {
    if (this.loadedLayers.has(layerName)) {
      return this.mapEngine.layers.get(layerName)
    }
    
    if (this.loadingLayers.has(layerName)) {
      // 等待正在加载的图层
      return this.waitForLayer(layerName)
    }
    
    this.loadingLayers.add(layerName)
    
    try {
      const layer = await this.createLayer(layerConfig)
      this.mapEngine.addLayer(layerName, layer)
      this.loadedLayers.add(layerName)
      return layer
    } catch (error) {
      console.error(`图层 ${layerName} 加载失败:`, error)
      throw error
    } finally {
      this.loadingLayers.delete(layerName)
    }
  }
  
  // 创建图层
  async createLayer(layerConfig) {
    // 模拟异步加载
    await new Promise(resolve => setTimeout(resolve, 100))
    
    if (layerConfig.type === 'wms') {
      return new TileLayer({
        source: new ImageWMS({
          url: layerConfig.url,
          params: layerConfig.params
        }),
        opacity: layerConfig.opacity || 1.0
      })
    } else if (layerConfig.type === 'tif') {
      return new TileLayer({
        source: new XYZ({
          url: layerConfig.url
        }),
        opacity: layerConfig.opacity || 0.8
      })
    }
    
    throw new Error(`不支持的图层类型: ${layerConfig.type}`)
  }
  
  // 等待图层加载完成
  async waitForLayer(layerName) {
    return new Promise((resolve, reject) => {
      const checkInterval = setInterval(() => {
        if (this.loadedLayers.has(layerName)) {
          clearInterval(checkInterval)
          resolve(this.mapEngine.layers.get(layerName))
        } else if (!this.loadingLayers.has(layerName)) {
          clearInterval(checkInterval)
          reject(new Error(`图层 ${layerName} 加载失败`))
        }
      }, 100)
    })
  }
}

export default LazyLayerLoader
```

### 7.2 组件性能优化

#### 虚拟滚动
```javascript
// 大列表虚拟滚动组件
import { ref, computed, onMounted, onUnmounted } from 'vue'

export default {
  name: 'VirtualList',
  props: {
    items: {
      type: Array,
      required: true
    },
    itemHeight: {
      type: Number,
      default: 50
    },
    containerHeight: {
      type: Number,
      default: 400
    }
  },
  setup(props) {
    const containerRef = ref(null)
    const scrollTop = ref(0)
    
    // 计算可见项目
    const visibleItems = computed(() => {
      const startIndex = Math.floor(scrollTop.value / props.itemHeight)
      const endIndex = Math.min(
        startIndex + Math.ceil(props.containerHeight / props.itemHeight) + 1,
        props.items.length
      )
      
      return props.items.slice(startIndex, endIndex).map((item, index) => ({
        ...item,
        index: startIndex + index,
        top: (startIndex + index) * props.itemHeight
      }))
    })
    
    // 总高度
    const totalHeight = computed(() => props.items.length * props.itemHeight)
    
    // 处理滚动
    const handleScroll = (event) => {
      scrollTop.value = event.target.scrollTop
    }
    
    onMounted(() => {
      if (containerRef.value) {
        containerRef.value.addEventListener('scroll', handleScroll)
      }
    })
    
    onUnmounted(() => {
      if (containerRef.value) {
        containerRef.value.removeEventListener('scroll', handleScroll)
      }
    })
    
    return {
      containerRef,
      visibleItems,
      totalHeight
    }
  }
}
```

#### 防抖和节流
```javascript
// 防抖函数
export function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 节流函数
export function throttle(func, limit) {
  let inThrottle
  return function executedFunction(...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 在地图组件中使用
export default {
  setup() {
    const handleMapMove = throttle((event) => {
      // 处理地图移动事件
      console.log('地图移动:', event.coordinate)
    }, 100)
    
    const handleSearch = debounce((query) => {
      // 处理搜索请求
      console.log('搜索:', query)
    }, 300)
    
    return {
      handleMapMove,
      handleSearch
    }
  }
}
```

---

## 8. 错误处理和用户体验

### 8.1 错误边界处理

#### 全局错误处理
```javascript
// 全局错误处理
export function setupErrorHandling(app) {
  // Vue错误处理
  app.config.errorHandler = (err, vm, info) => {
    console.error('Vue错误:', err, info)
    
    // 发送错误报告
    reportError({
      type: 'vue',
      error: err.message,
      stack: err.stack,
      component: vm?.$options.name,
      info
    })
  }
  
  // 未捕获的Promise错误
  window.addEventListener('unhandledrejection', (event) => {
    console.error('未捕获的Promise错误:', event.reason)
    
    reportError({
      type: 'promise',
      error: event.reason?.message || 'Unknown promise rejection',
      stack: event.reason?.stack
    })
    
    event.preventDefault()
  })
  
  // 全局JavaScript错误
  window.addEventListener('error', (event) => {
    console.error('全局JavaScript错误:', event.error)
    
    reportError({
      type: 'javascript',
      error: event.error?.message || event.message,
      stack: event.error?.stack,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno
    })
  })
}

// 错误报告
function reportError(errorInfo) {
  // 发送到错误监控服务
  if (process.env.NODE_ENV === 'production') {
    // 发送到Sentry或其他错误监控服务
    console.log('发送错误报告:', errorInfo)
  }
}
```

#### 组件错误处理
```javascript
// 错误边界组件
export default {
  name: 'ErrorBoundary',
  props: {
    fallback: {
      type: Function,
      default: null
    }
  },
  data() {
    return {
      hasError: false,
      error: null
    }
  },
  errorCaptured(err, vm, info) {
    this.hasError = true
    this.error = err
    
    console.error('组件错误:', err, info)
    
    // 发送错误报告
    reportError({
      type: 'component',
      error: err.message,
      stack: err.stack,
      component: vm?.$options.name,
      info
    })
    
    return false
  },
  render() {
    if (this.hasError) {
      if (this.fallback) {
        return this.fallback(this.error)
      }
      
      return h('div', {
        class: 'error-boundary'
      }, [
        h('h3', '出现错误'),
        h('p', '页面加载出现问题，请刷新页面重试'),
        h('button', {
          onClick: () => {
            this.hasError = false
            this.error = null
          }
        }, '重试')
      ])
    }
    
    return this.$slots.default()
  }
}
```

### 8.2 加载状态管理

#### 加载状态组件
```javascript
// 加载状态管理
export default {
  name: 'LoadingManager',
  setup() {
    const loadingStates = ref(new Map())
    
    // 设置加载状态
    const setLoading = (key, loading) => {
      loadingStates.value.set(key, loading)
    }
    
    // 获取加载状态
    const isLoading = (key) => {
      return loadingStates.value.get(key) || false
    }
    
    // 批量设置加载状态
    const setBatchLoading = (keys, loading) => {
      keys.forEach(key => {
        loadingStates.value.set(key, loading)
      })
    }
    
    // 清除加载状态
    const clearLoading = (key) => {
      loadingStates.value.delete(key)
    }
    
    // 清除所有加载状态
    const clearAllLoading = () => {
      loadingStates.value.clear()
    }
    
    return {
      loadingStates,
      setLoading,
      isLoading,
      setBatchLoading,
      clearLoading,
      clearAllLoading
    }
  }
}
```

#### 骨架屏组件
```vue
<template>
  <div class="skeleton-container">
    <div v-if="type === 'card'" class="skeleton-card">
      <div class="skeleton-header"></div>
      <div class="skeleton-content">
        <div class="skeleton-line" v-for="i in lines" :key="i"></div>
      </div>
    </div>
    
    <div v-else-if="type === 'list'" class="skeleton-list">
      <div class="skeleton-item" v-for="i in count" :key="i">
        <div class="skeleton-avatar"></div>
        <div class="skeleton-text">
          <div class="skeleton-line"></div>
          <div class="skeleton-line short"></div>
        </div>
      </div>
    </div>
    
    <div v-else-if="type === 'table'" class="skeleton-table">
      <div class="skeleton-row" v-for="i in rows" :key="i">
        <div class="skeleton-cell" v-for="j in cols" :key="j"></div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'SkeletonLoader',
  props: {
    type: {
      type: String,
      default: 'card',
      validator: (value) => ['card', 'list', 'table'].includes(value)
    },
    lines: {
      type: Number,
      default: 3
    },
    count: {
      type: Number,
      default: 5
    },
    rows: {
      type: Number,
      default: 5
    },
    cols: {
      type: Number,
      default: 4
    }
  }
}
</script>

<style scoped>
.skeleton-container {
  animation: pulse 1.5s ease-in-out infinite;
}

.skeleton-card {
  background: white;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.skeleton-header {
  height: 20px;
  background: #f0f0f0;
  border-radius: 4px;
  margin-bottom: 15px;
}

.skeleton-line {
  height: 12px;
  background: #f0f0f0;
  border-radius: 4px;
  margin-bottom: 8px;
}

.skeleton-line.short {
  width: 60%;
}

.skeleton-list {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.skeleton-item {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.skeleton-avatar {
  width: 40px;
  height: 40px;
  background: #f0f0f0;
  border-radius: 50%;
}

.skeleton-text {
  flex: 1;
}

.skeleton-table {
  background: white;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.skeleton-row {
  display: flex;
  border-bottom: 1px solid #f0f0f0;
}

.skeleton-cell {
  flex: 1;
  height: 40px;
  background: #f0f0f0;
  margin: 5px;
  border-radius: 4px;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}
</style>
```

---

## 9. 测试策略

### 9.1 单元测试

#### 组件测试
```javascript
// tests/components/MapContainer.test.js
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import MapContainer from '@/components/MapContainer.vue'

describe('MapContainer', () => {
  let wrapper
  
  beforeEach(() => {
    wrapper = mount(MapContainer, {
      props: {
        fileId: 1
      }
    })
  })
  
  it('应该正确渲染地图容器', () => {
    expect(wrapper.find('.map-container').exists()).toBe(true)
    expect(wrapper.find('#map').exists()).toBe(true)
  })
  
  it('应该显示图层控制面板', () => {
    expect(wrapper.find('.layer-control-panel').exists()).toBe(true)
    expect(wrapper.find('.panel-header h3').text()).toBe('图层控制')
  })
  
  it('应该正确处理fileId变化', async () => {
    await wrapper.setProps({ fileId: 2 })
    expect(wrapper.vm.fileId).toBe(2)
  })
  
  it('应该切换面板显示状态', async () => {
    const toggleBtn = wrapper.find('.toggle-btn')
    await toggleBtn.trigger('click')
    expect(wrapper.vm.panelVisible).toBe(false)
  })
  
  it('应该更新TIF图层透明度', async () => {
    const opacitySlider = wrapper.find('input[type="range"]')
    await opacitySlider.setValue(0.5)
    expect(wrapper.vm.tifLayerOpacity).toBe(0.5)
  })
})
```

#### API测试
```javascript
// tests/api/geoserver.test.js
import { describe, it, expect, vi } from 'vitest'
import { getWmsLayerUrl, getWfsLayerUrl, getMapConfig } from '@/api/geoserver'

describe('GeoServer API', () => {
  it('应该生成正确的WMS图层URL', () => {
    const url = getWmsLayerUrl('cementPlants', {
      BBOX: '114,30,115,31',
      WIDTH: 256,
      HEIGHT: 256
    })
    
    expect(url).toContain('SERVICE=WMS')
    expect(url).toContain('LAYERS=cement:cement_plants')
    expect(url).toContain('BBOX=114,30,115,31')
  })
  
  it('应该生成正确的WFS图层URL', () => {
    const url = getWfsLayerUrl('cementPlants', {
      MAXFEATURES: 100
    })
    
    expect(url).toContain('SERVICE=WFS')
    expect(url).toContain('TYPENAME=cement:cement_plants')
    expect(url).toContain('MAXFEATURES=100')
  })
  
  it('应该返回正确的地图配置', () => {
    const config = getMapConfig()
    
    expect(config).toHaveProperty('center')
    expect(config).toHaveProperty('zoom')
    expect(config).toHaveProperty('projection')
    expect(config.center).toEqual([114.3, 30.6])
    expect(config.zoom).toBe(8)
  })
})
```

### 9.2 集成测试

#### E2E测试
```javascript
// tests/e2e/map.spec.js
import { test, expect } from '@playwright/test'

test.describe('地图功能测试', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/map')
  })
  
  test('应该正确加载地图页面', async ({ page }) => {
    await expect(page.locator('.map-container')).toBeVisible()
    await expect(page.locator('#map')).toBeVisible()
  })
  
  test('应该显示图层控制面板', async ({ page }) => {
    await expect(page.locator('.layer-control-panel')).toBeVisible()
    await expect(page.locator('.panel-header h3')).toHaveText('图层控制')
  })
  
  test('应该切换底图', async ({ page }) => {
    const baseMapSelect = page.locator('select')
    await baseMapSelect.selectOption('satellite')
    
    // 验证底图切换
    await expect(baseMapSelect).toHaveValue('satellite')
  })
  
  test('应该显示TIF图层控制', async ({ page }) => {
    await page.goto('/map?fileId=1')
    
    await expect(page.locator('#tif-layer')).toBeVisible()
    await expect(page.locator('label[for="tif-layer"]')).toContainText('TIF影像')
  })
  
  test('应该调整TIF图层透明度', async ({ page }) => {
    await page.goto('/map?fileId=1')
    
    const opacitySlider = page.locator('input[type="range"]')
    await opacitySlider.fill('0.5')
    
    await expect(page.locator('span')).toContainText('50%')
  })
})
```

---

## 10. 部署和构建

### 10.1 Vite构建配置

#### 构建配置
```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          ol: ['ol'],
          utils: ['axios']
        }
      }
    }
  },
  
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:8085',
        changeOrigin: true
      }
    }
  },
  
  preview: {
    port: 4173
  }
})
```

#### 环境配置
```javascript
// 环境变量配置
const config = {
  development: {
    apiBaseUrl: 'http://localhost:8085/api',
    geoserverUrl: 'http://localhost:8080/geoserver',
    mockMode: true
  },
  production: {
    apiBaseUrl: '/api',
    geoserverUrl: '/geoserver',
    mockMode: false
  }
}

export default config[process.env.NODE_ENV || 'development']
```

### 10.2 部署脚本

#### 构建脚本
```bash
#!/bin/bash
# build.sh

echo "开始构建前端项目..."

# 安装依赖
npm install

# 运行测试
npm run test:unit

# 构建生产版本
npm run build

# 检查构建结果
if [ -d "dist" ]; then
  echo "构建成功！"
  echo "构建文件位于 dist/ 目录"
else
  echo "构建失败！"
  exit 1
fi
```

#### 部署脚本
```bash
#!/bin/bash
# deploy.sh

echo "开始部署前端项目..."

# 构建项目
npm run build

# 复制到服务器
scp -r dist/* user@server:/var/www/html/

# 重启Nginx
ssh user@server "sudo systemctl reload nginx"

echo "部署完成！"
```

---

## 总结

本文档详细分析了水泥厂管理系统中前端WebGIS部分的技术实现，包括：

### 核心技术特性
1. **Vue 3 + Composition API**: 现代化的前端框架和API
2. **OpenLayers集成**: 专业的地图渲染引擎
3. **GeoServer服务**: 标准化的地图服务接口
4. **TIF文件管理**: 完整的地理数据文件管理
5. **响应式设计**: 适配各种设备尺寸
6. **性能优化**: 瓦片缓存、懒加载、虚拟滚动
7. **错误处理**: 完善的错误边界和用户体验

### 技术优势
1. **模块化架构**: 清晰的组件划分和职责分离
2. **类型安全**: TypeScript支持（可选）
3. **测试覆盖**: 单元测试和E2E测试
4. **性能优化**: 多种性能优化策略
5. **用户体验**: 加载状态、错误处理、响应式设计

### 扩展性
1. **插件化**: 支持地图插件扩展
2. **主题化**: 支持多种UI主题
3. **国际化**: 支持多语言
4. **移动端**: 响应式设计适配移动设备
